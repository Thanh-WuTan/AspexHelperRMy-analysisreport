\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[T5]{fontenc}
\usepackage[svgnames]{xcolor}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{array}
\usepackage{lscape}
\usepackage[top=15mm, left=15mm, right=15mm, bottom=35mm]{geometry}

\usepackage{parskip}
\usepackage{tabularx}
\usepackage{titlesec}
\usepackage{float}
\usepackage{lmodern}
\usepackage{minted} 
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{seqsplit} % Essential for wrapping long numbers/hashes

\usepackage{changepage}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz}
\usepackage{amsmath} 
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}

\usepackage[vietnam]{babel}
\usepackage{enumitem}

\usepackage{tikz}
\usetikzlibrary{arrows.meta, shapes, positioning}
\usepackage{caption}
\captionsetup[figure]{list=no} % This hides ALL figures from the list by default

\setlist[itemize]{label=-}
\lstset { %
    language=python,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}
\usepackage{diagbox}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[thinc]{esdiff}
\DeclareUnicodeCharacter{2212}{-}
\DeclareUnicodeCharacter{2223}{|}

%%%% Headers %%%%
\pagestyle{fancy}
\headheight 54pt

\fancyhead[L]{\includegraphics[height=2.8\baselineskip]{\logo}}

\fancypagestyle{plain}{
    \fancyhf{} % Clear default plain settings
    \fancyhead[L]{\includegraphics[height=2.8\baselineskip]{\logo}} % Add your logo
    \renewcommand{\headrulewidth}{0.4pt} % Add the header line
    \fancyfoot[C]{\thepage} % Keep the page number at the center bottom
}

% --- Header Configuration ---
\pagestyle{fancy}
\fancyhf{} % 1. Clear all existing default headers/footers
\headheight 54pt

% 2. Left Side: Your Logo
\fancyhead[L]{\includegraphics[height=2.8\baselineskip]{\logo}}

% 3. Right Side: The "Lowest" Section Name
% \rightmark holds the section info. \nouppercase keeps it readable.
\fancyhead[R]{\nouppercase{\rightmark}} 

% 4. Define what goes into the marks (The Hierarchy)
% Chapter clears the right mark (starts fresh)
\renewcommand{\chaptermark}[1]{\markboth{#1}{}} 

% Section sets the right mark (e.g., "2.1 Overview")
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}} 

% Subsection ALSO sets the right mark (e.g., "2.1.1 Sample Information")
% This ensures if you are deep in a subsection, that name is shown.
\renewcommand{\subsectionmark}[1]{\markright{\thesubsection\ #1}} 

% Optional: Ensure the line is drawn
\renewcommand{\headrulewidth}{0.4pt}

% Ensure logo command is defined
\newcommand{\logo}{vinsoclogo.png}

% --- Header Configuration ---
\pagestyle{fancy}
\fancyhf{} % 1. This CLEARS everything (including page numbers)
\headheight 54pt

% 2. Left Side: Your Logo
\fancyhead[L]{\includegraphics[height=2.8\baselineskip]{\logo}}

% 3. Right Side: The "Lowest" Section Name
\fancyhead[R]{\nouppercase{\rightmark}} 

% 4. *** ADD THIS LINE HERE ***
\fancyfoot[C]{\thepage}
\setcounter{tocdepth}{3}
\begin{document}


\begin{titlepage}
    % --- CRITICAL: This command forces the header/footer to appear on this page ---
    \thispagestyle{empty} 
    
    \centering
    % Add vertical space to push title down slightly (adjust 3cm to move up/down)
    \vspace*{3cm} 

    % --- Title Section ---
    {\scshape\LARGE Malware Analysis Report \par} 
    \vspace{0.5cm}
    
    \hrule height 2pt % Thick visual line
    \vspace{0.5cm}
    
    {\Huge \bfseries AspexHelperRMy\par} 
    \vspace{0.3cm}
    {\Large \itshape A PlugX Variant \par} 
    
    \vspace{0.5cm}
    \hrule height 2pt 
    
    \vspace{3cm}

    % --- Author Section (Centered and Balanced) ---
    \begin{minipage}{0.45\textwidth}
        \begin{flushleft} \large
            \emph{Prepared by:}\\
            \textbf{VU Ai Thanh} \\
            (Vũ Ái Thanh)
        \end{flushleft}
    \end{minipage}%
    \begin{minipage}{0.45\textwidth}
        \begin{flushright} \large
            \emph{Supervised by:} \\
            \textbf{LE Van Minh Vuong} \\
            (Lê Văn Minh Vương)
        \end{flushright}
    \end{minipage}

    \vfill % Pushes the date to the bottom
    
    % --- Date Section ---
    {\large \today\par} 

\end{titlepage}

% Reset page counter so the next page is Page 1
\setcounter{page}{1}

\tableofcontents
\clearpage

\listoffigures
\clearpage

\listoftables
\clearpage
%
%\begin{figure}[H]
%    \centering
%    \includegraphics[width=1\linewidth]%{images/caldera.png}
%   \caption{Giao diện Caldera}
%    \label{fig:enter-label}
%\end{figure}

\chapter{Introduction}
\section{Overview}
Modern malware often employs multi-stage loaders, encrypted payloads, and in-memory execution techniques to evade traditional detection mechanisms. PlugX, in particular, is known for its modular architecture and frequent use of DLL side-loading to deliver payloads stealthily. The sample analyzed in this report follows this style, leveraging a signed loader and a reflectively loaded payload to achieve fileless execution.

\subsection{Sample Information}

The malware sample consists of the following files:

\begin{table}[H]
\centering
\label{tab:file_artifacts}
\begin{tabularx}{\textwidth}{@{}l X@{}}
\textbf{File Name:} & aspex\_helper.exe \\
\textbf{Size (bytes):} & 5,131,712 \\
\textbf{Type:} & Application (.exe) \\
\textbf{SHA-256:} & \seqsplit{ff2ba3ae5fb195918ffaa542055e800ffb34815645d39377561a3abdfdea2239} \\
\\
\textbf{File Name:} & aspex\_log.dat \\
\textbf{Size (bytes):} & 472,064 \\
\textbf{Type:} & DAT file \\
\textbf{SHA-256:} & \seqsplit{bc8091166abc1f792b895e95bf377adc542828eac934108250391dabf3f57df9} \\
\\
\textbf{File Name:} & RBGUIFramework.dll \\
\textbf{Size (bytes):} & 130,048 \\
\textbf{Type:} & Application Extension (.dll) \\
\textbf{SHA-256:} & \seqsplit{9f57f0df4e047b126b40f88fdbfdba7ced9c30ad512bfcd1c163ae28815530a6} \\
\end{tabularx}
\caption{Summary of Analyzed File Artifacts} 
\end{table}

\subsection{Overview of the Loading Chain}

Together, these files form a multi-stage loader sequence designed to deploy a memory-resident PlugX payload. The signed executable acts as a decoy loader, the DLL is side-loaded to decrypt the \texttt{.dat} file, and the decrypted content contains a reflective loader that executes the final payload entirely in memory. This fileless approach significantly reduces forensic artifacts on disk and complicates detection.

The following diagram summarizes the process flow of the sample:
\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=12mm and 18mm,
    box/.style={
        rectangle,
        rounded corners,
        draw=black,
        thick,
        align=center,
        minimum width=42mm,
        minimum height=12mm,
        fill=gray!10
    },
    arrow/.style={
        -{Latex[length=3mm]},
        thick
    }
]

% Nodes
\node[box] (exe) {Stage 1:\\\textbf{aspex\_helper.exe}\\(Signed Loader)};
\node[box, below=of exe] (dll) {Stage 2:\\\textbf{RBGUIFramework.dll.dll}\\(Side-Loaded DLL)};
\node[box, below=of dll] (reflect) {Stage 3:\\\textbf{aspex\_log.dat}\\(Decrypted Payload)};
\node[box, below=of reflect] (plugx) {Stage 4:\\\textbf{Final Payload}\\(Reflective-Loaded DLL )};

% Arrows
\draw[arrow] (exe) -- (dll);
\draw[arrow] (dll) -- (reflect);
\draw[arrow] (reflect) -- (plugx);

\end{tikzpicture}
\captionsetup{list=yes} 
\caption{Simplified 4-Stage Process Flow of AspesHelperRMy (PlugX Variant)}
\end{figure}


This report provides a brief overview of the loading chain and focuses primarily on the final decrypted PlugX payload and its behavior once executed in memory.

\chapter{Technical Analysis}

\section{Stage 1: aspex\_helper.exe}

The file \texttt{aspex\_helper.exe} is digitally signed, which helps it appear legitimate and evade initial suspicion during analysis or automated scanning. The digital signature details are shown below:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\textwidth]{images/signatureofexe.png}
    \caption{Digital signature information of \texttt{aspex\_helper.exe}}
\end{figure}

The executable itself contains minimal functionality. Its main purpose is to load the malicious DLL (\texttt{RBGUIFramework.dll}) through DLL side-loading. The file acts as a decoy loader and does not directly implement malicious logic.

The relevant portion of the decompiled code responsible for loading the DLL is shown below:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{images/aspex_helper.exe.png}
    \caption{Decompiled code of \texttt{aspex\_helper.exe} showing DLL loading behavior}
\end{figure}

\section{Stage 2: RBGUIFramework.dll}

Once the DLL is loaded, follow the execution of the main exported function.  
During its initialization routine, the function locates and reads the associated
\texttt{.dat} payload file. The contents of this file are then decrypted using
the hard-coded RC4 key:

\begin{center}
\texttt{LFMLljmhosPJfRHe}
\end{center}

The decryption routine is performed via the malware's internal function
\texttt{mw\_RC4Encryptpayload}. The relevant code region from the decompiler is
shown below.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{images/readanddecryptdat.png}
    \caption{Decompiled code reading and decrypting  \texttt{.dat} file.}
\end{figure}

\subsection*{Manual Payload Decryption}

For analysis purposes, the payload can also be decrypted manually using a Python
implementation of the same RC4 routine. The following script accepts an input
file and produces the decrypted output file:

\begin{lstlisting}[language=Python]
import sys

def rc4_transform(blob: bytes, secret: str) -> bytes:
    k = secret.encode
    box = list(range(256))
    y = 0

    # KSA
    for x in range(256):
        y = (y + box[x] + k[x % len(k)]) % 256
        box[x], box[y] = box[y], box[x]

    # PRGA
    a = b = 0
    result = bytearray

    for ch in blob:
        a = (a + 1) % 256
        b = (b + box[a]) % 256
        box[a], box[b] = box[b], box[a]
        idx = (box[a] + box[b]) % 256
        result.append(ch ^ box[idx])

    return bytes(result)


secret_key = "LFMLljmhosPJfRHe"
src = sys.argv[1]
dst = sys.argv[2]

with open(src, "rb") as f:
    encrypted = f.read

decrypted = rc4_transform(encrypted, secret_key)

with open(dst, "wb") as f:
    f.write(decrypted)
\end{lstlisting}

This script can be used to decrypt the payload manually during offline analysis.

\begin{figure}[H]
    \centering
    % Replace 'payload_compare_placeholder.png' with your actual comparison image
    \includegraphics[width=0.7\textwidth]{images/decryptedpayload.png}
    \captionsetup{list=yes} 
    \caption{Payload before and after RC4 decryption.}
\end{figure}

After decrypting the \texttt{.dat} file, the malware allocates memory, writes the decrypted payload into it, and sets appropriate memory protections to enable execution. The process involves:

\begin{itemize}
    \item Allocating memory via \texttt{NtAllocateVirtualMemory}.
    \item Writing the decrypted payload to the allocated memory using \texttt{ZwWriteVirtualMemory}.
    \item Changing memory protection to executable using \texttt{ZwProtectVirtualMemory}.
    \item Registering the entry point of the decrypted payload as a callback through \texttt{EnumSystemGeoID}.
\end{itemize}

Interestingly, the malware uses \texttt{EnumSystemGeoID} to indirectly invoke the pointer to the decrypted payload stored in \texttt{lpGeoEnumProc}. This allows the payload to execute entirely in memory without being written to disk, a common fileless malware technique.

\begin{figure}[H]
    \centering
    % Replace 'in_memory_placeholder.png' with your actual decompiled code screenshot
    \includegraphics[width=0.8\textwidth]{images/executefinalpayload.png}
    \caption{Decompiled code for memory allocation and callback setup for payload execution}
\end{figure}

 
\section{Stage 3: Reflective DLL Loader}

Once the \texttt{EnumSystemGeoID} API is invoked, execution is transferred directly into the
decrypted payload, which is treated as shellcode. The first bytes of this payload contain a
Reflective DLL Loading stub responsible for redirecting program flow into the main
reflective loader embedded within the decrypted DLL. This mechanism allows the payload
to be mapped and executed entirely in memory without ever touching disk.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{images/reflectiveloader.png}
\caption{Reflective loader stub at the beginning of the decrypted payload}
\end{figure}

The reflective loader serves as the only exported function within the decrypted DLL,
named \texttt{RunInit}, which is later invoked to begin execution of the final PlugX stage.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/exportedfunction.png}
\caption{Export table showing the single exported function \texttt{RunInit}}
\end{figure}

\section{Stage 4: The Final Payload} 
\subsection{Overview of Final Payload Behavior}

The following control‑flow graph provides a high‑level view of the payload’s execution logic. It illustrates how the malware initializes its environment, processes command‑line arguments, and selects different execution paths before ultimately converging into its primary operational routine.

\begin{landscape}
\begin{figure}[H]
\centering
\resizebox{1.2\textwidth}{!}{
\begin{tikzpicture}[
    node distance=22mm,
    every node/.style={font=\small},
    startstop/.style={rectangle, rounded corners, draw, align=center, minimum width=32mm, minimum height=7mm},
    process/.style={rectangle, draw, align=center, minimum width=36mm, minimum height=7mm},
    decision/.style={diamond, draw, aspect=2, align=center},
    arrow/.style={->, thick},
]

% --- Central Flow ---
\node (start) [startstop] {Start};
\node (resolve) [process, below of=start] {ResolveRequiredAPIs};
\node (setup) [process, below of=resolve, yshift=-4mm] {Setup Environment \\ Decrypt Config \\ Parse Arguments};
\node (argSwitch) [decision, below of=setup, yshift=-4mm] {Argument Count};

% --- Case 5 (Center): MainRoutine ---
\node (case5) [process, below of=argSwitch, yshift=-35mm] {MainRoutine};

% --- Case 2 (Left-Center): UAC Bypass ---
\node (case2) [process, left=35mm of case5] {SetupUACBypassAndRerun(3)};
\node (exit2) [startstop, below of=case2] {Exit};

% --- Case 3 (Far Left): Explorer/Mutex simplified ---
\node (case3) [process, left=55mm of case2] {Explorer Refresh};
\node (mutex3) [process, below of=case3] {Create Mutex};
\node (exists3) [decision, below of=mutex3, yshift=-4mm] {Already Exists?};
\node (close3) [process, below right=10mm and 10mm of exists3] {Exit};
\node (install3) [process, below of=exists3, yshift=-20mm] {Install + Persistence};
\node (adminOK3) [decision, below of=install3, yshift=-4mm] {Is Admin?};
\node (callMain3) [process, below left=30mm and -10mm of adminOK3] {MainRoutine};
\node (exit3) [startstop, below right=10mm and -10mm of adminOK3] {Exit};


% --- Case 4 (Right-Center): Injection ---
\node (case4) [process, right=35mm of case5] {CheckInjectionFlag};
\node (injFlag) [decision, below of=case4, yshift=-4mm] {Flag = 1?};
\node (decrypt4) [process, below right=10mm and -10mm of injFlag] {LoadAndInjectPayload};
\node (exit4) [startstop, below of=decrypt4] {Exit};
\node (main4) [process, below left=30mm and -10mm of injFlag] {MainRoutine};

% --- Case 1 (Far Right): Install ---
\node (case1) [process, right=55mm of case4] {Install + Persistence};
\node (isAdmin1) [decision, below of=case1, yshift=-4mm] {Is Admin?};
\node (exit1) [startstop, below right=10mm and -10mm of isAdmin1] {Exit};
\node (callMain1) [process, below left=20mm and -10mm of isAdmin1] {MainRoutine};

% --- Edges ---
\draw [arrow] (start) -- (resolve);
\draw [arrow] (resolve) -- (setup);
\draw [arrow] (setup) -- (argSwitch);

% Edge: Case 5
\draw [arrow] (argSwitch) -- node[right]{5} (case5);

% Edge: Case 2
\draw [arrow] (argSwitch) -- node[above, near start]{2} (case2);
\draw [arrow] (case2) -- (exit2);

% --- Edges for Case 3 simplified ---
\draw [arrow] (argSwitch) -- node[above, near start]{3} (case3);
\draw [arrow] (case3) -- (mutex3);
\draw [arrow] (mutex3) -- (exists3);
\draw [arrow] (exists3) -- node[above]{Yes} (close3);
\draw [arrow] (exists3) -- node[above]{No} (install3);
\draw [arrow] (install3) -- (adminOK3);
\draw [arrow] (adminOK3) -- node[above]{Yes} (exit3);
\draw [arrow] (adminOK3) -- node[above]{No} (callMain3);

% Edge: Case 4
\draw [arrow] (argSwitch) -- node[above, near start]{4} (case4);
\draw [arrow] (case4) -- (injFlag);
\draw [arrow] (injFlag) -- node[above]{Yes} (decrypt4);
\draw [arrow] (decrypt4) -- (exit4);
\draw [arrow] (injFlag) -- node[above]{No} (main4);

% --- Edge: Case 1 simplified ---
\draw [arrow] (argSwitch) -- node[above, near start]{1} (case1);
\draw [arrow] (case1) -- (isAdmin1);
\draw [arrow] (isAdmin1) -- node[above]{Yes} (exit1);
\draw [arrow] (isAdmin1) -- node[above]{No} (callMain1);
\end{tikzpicture}
}
\captionsetup{list=yes} 
\caption{Final Payload's control flow overview}
\end{figure}
\end{landscape}

\begin{table}[H]
\centering
\label{tab:arg_logic}
\begin{tabularx}{\textwidth}{@{} c X @{}}
\toprule
\textbf{Argc} & \textbf{Execution Behavior} \\ \midrule
1 & Sets up persistence. Checks privilege level: if running as a standard user, it calls \texttt{MainRoutine}; if running as Admin, it exits normally. \\ \addlinespace
2 & Configures UAC bypass using \texttt{fodhelper.exe} to elevate privileges to re-runs the malware with 3 additional arguments (resulting in argc = 4). \\ \addlinespace
3 & Decoy Folder Open: Forces a fresh Explorer window of the host drive to appear while closing the original window, tricking the user into believing they successfully opened a folder. Then proceeds similarly to the \texttt{argc = 1} case. \\ \addlinespace
4 & Checks the injection flag in the configuration. If the flag is set, it injects the encrypted payload (\texttt{aspex\_log.dat}) into \texttt{dllhost.exe} and re-runs the malware with 4 additional arguments (resulting in argc = 5). Otherwise, it calls \texttt{MainRoutine}. \\ \addlinespace
5 & Directly invokes \texttt{MainRoutine}. \\ \bottomrule
\end{tabularx}

\caption{Control Flow Logic by Argument Count}
\end{table}

At the core of these paths is the \texttt{MainRoutine} function. Once reached, this routine carries out the payload’s main malicious activities. It systematically enumerates all connected removable USB drives and infects each one to support self‑propagation. In addition, it establishes and 
maintains communication with the attacker’s command‑and‑control (C2) server, enabling remote command execution and data transmission.



\subsection{Obfuscation Techniques}

The malware employs a heavily obfuscated and non‑uniform string decoding technique to
conceal API names. Each obfuscated string is reconstructed at runtime using a sequence of
operations such as writing hardcoded 32‑bit or 64‑bit values into a local buffer, followed by
byte‑wise transformations (e.g., XOR with loop‑dependent values, arithmetic offsets, or
position‑based mutations). The two code samples below illustrate this behavior: although the
overall goal is the same, each routine uses a different combination of constants, offsets and
XOR operations, making it difficult to identify a single decoding pattern.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\linewidth]{images/stringobfuscation1.png}
\caption{String obfuscation routine (example 1).}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\linewidth]{images/stringobfuscation2.png}
\caption{String obfuscation routine (example 2).}
\end{figure}


After the obfuscated bytes are transformed into a readable ASCII string, the malware passes
the resulting buffer directly to its internal API‑resolution wrapper
\texttt{mw\_GetProcAddress\_wrapper}), which ultimately calls
\texttt{GetProcAddress}. This allows the sample to dynamically resolve Windows API functions while ensuring that none of the function names exist in plaintext within the binary.

\subsection{Single Instance Enforcement via Mutex}

To ensure stability and prevent resource conflicts, the malware implements a strict single-instance policy for its core threads and worker routines. This is achieved through the systematic use of named Mutexes.

For every distinct worker thread or malware instance, a unique Mutex name is generated. Upon initialization, the routine attempts to acquire this Mutex using the \texttt{CreateMutexW} API. The code immediately checks the result using \texttt{GetLastError}.

\begin{itemize}
    \item \textbf{Already Exists:} If the error code corresponds to \texttt{ERROR\_ALREADY\_EXISTS}, the malware recognizes that an instance of this specific routine is already running. It consequently aborts the current function execution to prevent duplication.
    \item \textbf{New Instance:} If the Mutex is successfully created, the thread "owns" the object and proceeds to execute its malicious payload.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/mutex.png}
    \caption{Decompiled code showing the Mutex creation and existence check.}
    \label{fig:mutex_check}
\end{figure}

\bigskip

\noindent\textbf{Analyst Note regarding API Resolution Wrappers:}

Throughout this report and the detailed screenshots, functions appearing with names such as \\ \texttt{mw\_resolveaddress\_X} (e.g., \texttt{mw\_resolveaddress\_2}, \texttt{mw\_resolveaddress\_9}) are functionally identical to the \texttt{mw\_GetProcAddress\_wrapper} described in the \textit{Obfuscation Techniques} section. These represent different compiled instances of the same dynamic API resolution logic, used by various threads to reconstruct API pointers at runtime without exposing them in the Import Address Table (IAT).

\subsection{Decrypting Config Data}

The malware stores its configuration settings in an encrypted global buffer. Static analysis of the code reveals that the binary utilizes the RC4 stream cipher to decrypt this information at runtime.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/decompiledcodedecryptconfig.png}
    \caption{Decompiled routine responsible for decrypting the embedded configuration data.}
\end{figure}

The decryption routine performs the following operations:
\begin{enumerate}
    \item \textbf{Key Extraction:} The code reads the first 4 bytes of the encrypted blob. As seen in the raw data, these bytes are \texttt{0x7A 0x27 0x02 0x00}. The malware uses \texttt{wsprintfA} with the \texttt{"\%X"} format specifier to convert these bytes into a hexadecimal string, which serves as the RC4 decryption key.
    \item \textbf{Payload Decryption:} The remaining 3624 bytes of the buffer (offsets following the key) constitute the actual encrypted configuration.
    \item \textbf{RC4 Execution:} The function \texttt{RC4\_EncryptDecrypt\_Wrapper} is invoked with the derived key and the encrypted payload to recover the plaintext data.
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/encryptedconfig.png}
    \caption{Encrypted configuration blob in HxD: first 4 bytes are used as the RC4 key.}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/decryptedconfig.png}
    \caption{Decrypted configuration data extracted from the final payload}
\end{figure}

\begin{figure}[H]
    \centering
    \captionsetup{list=yes} \includegraphics[width=0.8\textwidth]{images/c2serveraddressandport.png}
    \caption{Extracted C2 server addresses and ports from the decrypted configuration.}
    \label{fig:c2_config_addresses}
\end{figure}

\subsection{Compromised Host Fingerprinting}

The malware establishes a distinct identity for each infected host by assigning a unique "fingerprint." This identifier serves a dual purpose: it allows the Command and Control (C2) server to differentiate between victims for precise tasking, and it acts as the directory name for the hidden staging folders created on infected USB drives.

It is retrieved directly from the malware's embedded configuration data. The ID consists of a 16-byte hexadecimal string, formatted using the following pattern:

\begin{center}
    \texttt{\%2.2X\%2.2X\%2.2X\%2.2X\%2.2X\%2.2X\%2.2X\%2.2X}
\end{center}

To ensure the ID remains persistent across reboots and subsequent executions, the malware writes the generated VictimID to the Windows Registry. It targets both the machine-wide and user-specific hives under the \texttt{ms-pu} key:

\begin{itemize}
    \item \texttt{HKEY\_LOCAL\_MACHINE\textbackslash Software\textbackslash CLASSES\textbackslash ms-pu\textbackslash CLSID}
    \item \texttt{HKEY\_CURRENT\_USER\textbackslash Software\textbackslash CLASSES\textbackslash ms-pu\textbackslash CLSID}
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/host_fingerprinting.png}
    \caption{Registry artifact showing the persistent ID stored in the \texttt{ms-pu} key.}
    \label{fig:host_fingerprinting}
\end{figure}
\subsection{Privilege Level Detection}

The malware evaluates the current process's privilege level and assigns a numeric value indicating the type of access.  
These values can be interpreted as follows:
\begin{table}[H]
\centering

\label{tab:privilege_levels}
\begin{tabularx}{\textwidth}{@{}c X@{}}
\toprule
\textbf{Code} & \textbf{Privilege Description} \\
\midrule
0 -- Standard User (Not Admin) &
The process is running with Medium or Low integrity and has no administrative privileges.
The user is not a member of the local Administrators group.
Even if UAC is enabled, there is no split token because the user has no administrative token to split.
Administrative actions require providing an administrator's credentials; simply approving a UAC prompt is insufficient. \\ \addlinespace

1 -- Full Admin (Elevated) &
The process is running with High integrity and has full administrative privileges.
This occurs when the user explicitly launches the application with "Run as Administrator," uses the built-in Administrator account, or UAC is disabled globally.
The application has unrestricted access to system resources. \\ \addlinespace

2 -- Limited Admin (UAC Active) &
The process is running with Medium integrity, but the user is a member of the Administrators group.
UAC has filtered administrative privileges from the current token (split token).
The user has administrative potential but is not currently exercising it; elevation is required to perform administrative actions. \\
\bottomrule
\end{tabularx}
\caption{Privilege Level Codes and Their Meaning}
\end{table}

\subsection{Establishing Persistence}

Before creating its persistence mechanisms, the malware first attempts to copy its core
components (the `.exe`, `.dll`, and `.data` files) into a fixed installation directory
defined in its configuration. The primary target location is: \texttt{\%ALLUSERSPROFILE\%\textbackslash MSDN\textbackslash AspexHelperRMy\textbackslash}

If the malware does not have sufficient privileges to write to this directory,
it falls back to a user‑specific path: \texttt{\%USERPROFILE\%\textbackslash AspexHelperRMy\textbackslash}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/installmw.png}
\caption{The malware copies all of its payload components.}
\label{fig:payload_copy_msdn}
\end{figure}

\subsubsection{Scheduled Task–Based Persistence With Sufficient Privilege}
After determining the current privilege level, if the returned value is \textbf{1} (indicating
the process is running with full administrative privileges), the malware proceeds to
establish persistence by creating two scheduled tasks—both named
\texttt{AspexUpdateTask}. These tasks are configured to execute the malware every
30 minutes with three randomly generated arguments.

\begin{verbatim}
SCHTASKS.exe /create /sc minute /mo 30 /tn "AspexUpdateTask" ^
/tr "\"%ALLUSERSPROFILE%\MSDN\AspexHelperRMy\aspex_helper.exe\" rand1 rand2 rand3" ^
/ru "SYSTEM" /f

SCHTASKS.exe /create /sc minute /mo 30 /tn "AspexUpdateTask" ^
/tr "\"%ALLUSERSPROFILE%\MSDN\AspexHelperRMy\aspex_helper.exe\" rand1 rand2 rand3" /f
\end{verbatim}

Immediately after creating the task, the malware forces its execution with:

\begin{verbatim}
SCHTASKS.exe /run /tn "AspexUpdateTask"
\end{verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{images/schtask.png}
    \caption{Execution log showing the malware creating and running the scheduled task}
    \label{fig:schtask_log}
\end{figure}

\subsubsection{Registry-Based Persistence Under UAC-Limited Privileges}

If the privilege-checking function instead returns a value of \textbf{2} (indicating the
process is running under a UAC-restricted or non-elevated context), the malware
opts for a user-level persistence mechanism. In this case, it creates a registry
entry named \texttt{Aspex Update} under:

\texttt{HKEY\_CURRENT\_USER\textbackslash Software\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Run}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{images/setregkeypersistent.png}
    \caption{Registry entry created by the malware under HKCU\textbackslash{}\dots\textbackslash Run}
    \label{fig:registry_run_key}
\end{figure}

The value is configured to launch the malware’s executable at user logon, again
supplying \textbf{three} randomly generated arguments. Unlike the scheduled task method,
this technique does not require administrative privileges and therefore succeeds
even when the process is running without elevation.
 

\medskip

\noindent\textit{In both persistence scenarios—whether running with full administrative privileges or under UAC-limited privileges—the malware ultimately re-invokes itself with \textbf{argc = 4}. After completing the persistence setup, the process terminates cleanly by returning \textbf{0}.}

\subsection{Bypass UAC via Fodhelper.exe (Case Argc = 2)}

When the malware is executed with an argument count of 2, it initiates a User Account Control (UAC) bypass routine to elevate its privileges from Medium Integrity to High Integrity. This is a critical step for the malware to gain full administrative control over the infected host without alerting the user.

\subsubsection{Registry Manipulation (CurVer Redirection)}
The malware employs a "Fileless" UAC bypass technique involving registry redirection. Instead of writing a DLL to disk, it manipulates the registry keys associated with the \texttt{ms-settings} protocol.

Based on the dynamic analysis artifacts, the malware performs the following two specific registry operations:

\begin{enumerate}
    \item \textbf{Redirecting ms-settings:}
    It targets the key \texttt{HKCU\textbackslash Software\textbackslash Classes\textbackslash ms-settings\textbackslash CurVer}.
    It sets the default value to \texttt{.pow}. This instructs Windows that the "Current Version" of the program used to handle \texttt{ms-settings} requests is defined by the ProgID \texttt{.pow}.
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\linewidth]{images/mssetingspow.png}
        \caption{Registry Event: Redirecting the ms-settings CurVer to the custom ProgID .pow}
        \label{fig:curver_redirect}
    \end{figure}

    \item \textbf{Defining the Malicious Command:}
    It then creates the new ProgID key at \\ \texttt{HKCU\textbackslash Software\textbackslash Classes\textbackslash .pow\textbackslash Shell\textbackslash Open\textbackslash command}.
    It sets the default value to the path of the malicious executable followed by three additional arguments.
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\linewidth]{images/setkeypowshellopencommand.png}
        \caption{Registry Event: Setting the final payload execution command inside the .pow ProgID}
        \label{fig:payload_command}
    \end{figure}
\end{enumerate}

\subsubsection{Triggering the Bypass}
Once the registry is primed, the malware executes the Windows Features on Demand Helper using the command line:

\begin{verbatim}
C:\Windows\system32\cmd.exe /c fodhelper.exe
\end{verbatim}

The process tree below captures this behavior, showing \texttt{aspex\_helper.exe} spawning \texttt{cmd.exe}, which in turn launches \texttt{fodhelper.exe}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/processtreeafterfodhelper.png}
    \caption{The malware spawning cmd.exe to trigger the vulnerable fodhelper.exe binary.}
    \label{fig:fodhelper_trigger}
\end{figure}

\textbf{Mechanism of Execution:}
\begin{enumerate}
    \item \textbf{Auto-Elevation:} \texttt{fodhelper.exe} is a trusted Windows binary located in \texttt{System32} that possesses a manifest with \texttt{autoElevate=true}. When executed by a user in the Administrators group, it runs with High Integrity without prompting the user (no UAC pop-up).
    \item \textbf{Protocol Lookup:} Upon launch, \texttt{fodhelper.exe} attempts to open the \texttt{ms-settings} protocol to display system settings.
    \item \textbf{Registry Hijack:} Because of the registry modifications shown in Figure \ref{fig:curver_redirect}, \texttt{fodhelper} follows the \texttt{CurVer} pointer to \texttt{.pow} and executes the command defined in \texttt{.pow\textbackslash Shell\textbackslash Open\textbackslash command} (shown in Figure \ref{fig:payload_command}).
    \item \textbf{Privilege Inheritance:} Since \texttt{fodhelper.exe} is running as an elevated Administrator, the child process it spawns (the malware) inherits this High Integrity token.
\end{enumerate}

As a result, \texttt{aspex\_helper.exe} is re-executed with 3 additional arguments (total argc = 4) and full administrative privileges, allowing it to proceed to the next stage of infection.

\subsection{Process Injection via dllhost.exe (Case Argc = 4)}

When the malware is executed with an argument count of 4, it does not immediately execute the main payload. Instead, it consults its decrypted configuration data to determine the next course of action.

\subsubsection{Configuration Check}
The malware checks a specific flag within its configuration structure. As seen in the decompiled code below, if this flag is set (non-zero), the control flow is redirected to the \texttt{injection\_routine}. If the flag is not set, it proceeds directly to \texttt{mw\_main}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/case4.png}
    \caption{Decompiled logic for Argc=4: Checking the configuration flag to trigger injection.}
    \label{fig:injection_flag_check}
\end{figure}

\subsubsection{The Injection Routine}
If the injection flag is active, the malware initiates a process injection sequence targeting the legitimate Windows system component \texttt{\%windir\%\textbackslash system32\textbackslash dllhost.exe}. This technique is used to mask the malware's activity behind a trusted system process.

The routine follows these specific steps:

\textbf{1. Reading the Payload} \\
First, the malware resolves the path to the encrypted payload file, \texttt{aspex\_log.dat}. It reads the entire content of this file into a locally allocated memory buffer.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/injectionroutine.png}
    \caption{Reading the content of aspex\_log.dat into memory.}
    \label{fig:read_payload}
\end{figure}

\textbf{2. Spawning the Target Process} \\
The malware then launches a new instance of \texttt{dllhost.exe} using \texttt{CreateProcessW}. 
Notably, it constructs a command line with \textbf{4 additional arguments} (e.g., \texttt{rand1 rand2 rand3 rand4}), which effectively sets up the next stage of execution (Argc = 5).

The process creation flag is set to \textbf{20} (Decimal), which typically corresponds to \texttt{CREATE\_NEW\_CONSOLE | CREATE\_SUSPENDED}. This ensures the legitimate process starts in a suspended state, allowing the malware to modify its memory before it runs.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{images/createprocesswdllhost.png}
    \caption{Spawning dllhost.exe in a suspended state with 4 dummy arguments.}
    \label{fig:spawn_dllhost}
\end{figure}

\textbf{3. Injection and Execution} \\
With the target process suspended, the malware performs standard injection operations:
\begin{itemize}
    \item \textbf{Allocation:} It calls \texttt{VirtualAllocEx} to allocate memory within the remote \texttt{dllhost.exe} process.
    \item \textbf{Writing:} It uses \texttt{WriteProcessMemory} to copy the buffer containing the \texttt{aspex\_log.dat} content into the allocated remote memory.
    \item \textbf{Execution:} Finally, it invokes \texttt{CreateRemoteThread} to start a new thread in the remote process that executes the injected shellcode.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{images/injectdllhost.png}
    \caption{Writing payload to remote memory and creating a remote thread.}
    \label{fig:remote_thread_injection}
\end{figure}

Although the injection routine appears structurally sound at first glance, it contains a significant logical flaw. The malware loads the encrypted \texttt{aspex\_log.dat} payload from disk and writes it directly into the memory of the remote process \textit{without} decrypting it beforehand.

Because the payload remains encrypted, executing it inside the target process would immediately result in invalid instructions, causing \texttt{dllhost.exe} to crash. This strongly suggests a mistake in the implementation or that this section of code is a leftover from other PlugX variants where the full decryption-and-injection workflow was correctly implemented.

\subsection{Core Malicious Logic: The Main Routine}

Upon entering the final stage, the malware executes its primary operations. Despite the decompiled code displaying loop structures and conditional checks, the actual execution flow proceeds directly through three core functions in order.

\begin{figure}[H]
    \centering
    \captionsetup{list=yes} \includegraphics[width=0.85\linewidth]{images/mainroutine.png}
    \caption{The main routine executing the three core functions sequentially.}
    \label{fig:main_routine_linear}
\end{figure}

The malware executes the following functions sequentially:

\begin{enumerate}
    \item \textbf{mw\_infectusb\_and\_stealdata}: Contains the core logic of USB infection.
    \item \textbf{mw\_connecttointernet}: Periodically steals Wi-Fi credentials and attempts to use them to restore internet connectivity if offline.
    \item \textbf{mw\_c2communication}: Performs C2 communication.
\end{enumerate}

\subsubsection{USB Infection}

\textbf{Defense Evasion and Environment Sanitization}

The first major component called within the sequence is \texttt{mw\_infectusb\_and\_stealdata}. Before attempting to propagate, this function invokes a protective subroutine, \texttt{mw\_protect\_malware}, designed to sanitize the environment.

This routine serves a dual purpose: ensuring the stability of the malware by removing competing applications and evading detection by disabling specific security products.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{images/mwprotec.png}
    \caption{Protection and USB infection thread initialization.}
    \label{fig:mw_protect}
\end{figure}

\paragraph{Targeted Process Termination and Cleanup} \mbox{}\\
The malware takes a snapshot of all running processes on the system to identify potential threats. It iterates through this snapshot and compares every process name against a hardcoded blocklist.

If a match is found, the malware employs a dual-method approach to ensure the target is neutralized. First, it attempts to forcibly terminate the process tree using the Windows Command Processor:
\begin{center}
    \texttt{C:\textbackslash Windows\textbackslash system32\textbackslash cmd.exe /c taskkill /t /f /pid \%d}
\end{center}

In addition to the command-line approach, it also directly invokes the native Windows API \\ \texttt{TerminateProcess(hproc, 0)} on the target process handle.

The blocklist targets a mix of USB-focused security tools (e.g., Smadav), standard antivirus solutions (e.g., Avast, Symantec), and potentially other malware or system utilities. The full list of targeted processes is detailed below:

\begin{table}[H]
\centering
\label{tab:process_blocklist}
\begin{tabularx}{\textwidth}{>{\centering\arraybackslash}X >{\centering\arraybackslash}X >{\centering\arraybackslash}X}
\toprule
SZBrowser.exe & SmadavProtects.exe & SmadavProtect.exe \\
Microsoft\_Photos.exe & Microsoft\_Caps.exe & HpDigital.exe \\
EwsProxy.exe & AssistPro.exe & AvastNM.exe \\
AvastSvc.exe & acrotrays.exe & AcroRd32.exe \\
AAM Update.exe & AAM Updates.exe & AdobeUpdate.exe \\
AdobeUpdates.exe & AdobeHelper.exe & Symantec.exe \\
PowerUtility.exe & & \\
\bottomrule
\end{tabularx}

\caption{Blocklist of Processes Targeted for Termination}
\end{table}

Following the termination of the targeted processes, the malware executes a cleanup routine to permanently disable the security software. This process involves two distinct steps: physical file removal and persistence removal.

First, the malware locates the executable files associated with the terminated processes on the disk and attempts to delete them. This prevents the security tools from being manually restarted by the user or triggered by other system components.

Second, to ensure these applications do not launch automatically upon system reboot, the malware scans the standard Windows startup registry keys:

\begin{itemize}
    \item \texttt{HKEY\_LOCAL\_MACHINE\textbackslash Software\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Run}
    \item \texttt{HKEY\_CURRENT\_USER\textbackslash Software\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Run}
\end{itemize}

It iterates through the values within these keys. If it identifies an entry matching the name of a blocked application, it deletes the registry value, thereby removing the software's persistence mechanism.

\paragraph{USB Drive Enumeration and Infection Logic} \mbox{}\\
The \texttt{mw\_infect\_usb\_drivs} function acts as the primary controller for propagation. It executes an infinite loop that periodically calls \\ \texttt{GetLogicalDriveStringsW} to enumerate all mounted volumes on the system.

For every detected volume, the code verifies if the device is a removable USB drive via the helper function \texttt{mw\_CheckIfIsUsbDevice}. Upon validating a target drive, the malware spawns three distinct worker threads to concurrently manage the infection and data theft process:

\begin{enumerate}
    \item \texttt{mw\_ManageUsbDriveInfection}
    \item \texttt{mw\_ManageUsbDataTheft}
    \item \texttt{mw\_RunSomeBatScript}
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/usbinfector.png}
    \captionsetup{list=yes}
    \caption{The USB infection routine spawning three worker threads for each detected drive.}
    \label{fig:usb_infection_threads}
\end{figure}

\paragraph{Experimental Setup Note} \mbox{}\\
For the purpose of this analysis, the malware's propagation behavior was observed in a controlled environment. A virtual disk (Drive \texttt{E:}) was mounted within the virtual machine and explicitly configured to simulate the properties of a removable USB mass storage device. This setup successfully deceived the malware's drive type detection logic, allowing for the execution of the full infection chain.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/usbbeforeinfection.png}
    \caption{The simulated USB drive (Drive E:) containing user data before infection.}
    \label{fig:test_usb_setup}
\end{figure}

\subsubsection{Thread 1: Manage Usb Drive Infection}

\textbf{Enforcing Stealth via Registry Manipulation}
The first thread initiates a persistent loop that executes every 2 minutes. Its primary objective is to modify the Windows Explorer settings to aggressively conceal the malware's presence.

It targets the key \texttt{HKCU\textbackslash Software\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Explorer\textbackslash Advanced} and forcibly sets the following values:

\begin{itemize}
    \item \textbf{Hidden}: Set to \textbf{0} to disable the display of files with the "Hidden" attribute.
    \item \textbf{ShowSuperHidden}: Set to \textbf{0} to disable the display of protected operating system files.
    \item \textbf{HideFileExt}: Set to \textbf{1} to hide file extensions for known file types.
\end{itemize}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{images/mw_enforce_explorer_visibility_settings.png}
    \caption{ProcMon capture of malware enforcing hidden file settings.}
    \label{fig:procmon_hidden_registry}
\end{figure}

By continuously reverting these settings, malware ensures that its payloads, which are likely marked as hidden or system files—remain invisible to the user, complicating manual detection and removal.

\paragraph{Pre-Infection Validation and Safeguards}\mbox{}\\
Before performing any usb infection, the malware conducts a structured validation sequence to decide whether the attached USB drive qualifies for infection. As illustrated in Figure~\ref{fig:preinfectionlogic}, the decision process evaluates three factors: (i) device fingerprinting, (ii) host-side infection history, and (iii) a global propagation policy.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/usbcheckflag.png}
    \caption{Decompiled pre-infection decision logic.}
    \label{fig:preinfectionlogic}
\end{figure}

The routine begins by checking whether the malware's USB-propagation component in its config data is enabled through \texttt{mw\_is\_usb\_feature\_enabled}(for this sample, this specific component is not enabled). If the feature is active, the malware derives a device-specific identifier via \texttt{mw\_get\_usb\_unique\_path}, which resolves the physical interface path of the connected USB drive.

Next, the malware queries a tracking registry value using \texttt{mw\_is\_usb\_recorded\_in\_registry} to determine whether this specific USB identifier has previously been processed on the host. The registry path involved belongs to:
\[
\texttt{HKEY\_CURRENT\_USER\textbackslash System\textbackslash CurrentControlSet\textbackslash Control\textbackslash Network}
\]
\begin{itemize}
    \item \textbf{If the lookup returns \texttt{true}}, execution jumps to a cleanup routine, bypassing all further infection attempts.
    \item \textbf{Purpose:} This acts as a host-side idempotency check to prevent redundant processing of drives that are already known to the compromised system.
\end{itemize}

If the USB device has not been previously recorded, the malware evaluates a device-side marker by calling \texttt{mw\_is\_usb\_flag\_file\_set}. This function inspects a file on the USB drive (typically \texttt{desktop.ini}); if the first byte is the value ``1'', the routine returns \texttt{1}, signaling the device is already marked as infected.

The malware then calls \texttt{mw\_query\_usb\_allow\_registry} to read the policy value stored at:
\[
\texttt{HKEY\_CURRENT\_USER\textbackslash System\textbackslash CurrentControlSet\textbackslash Control\textbackslash Network\textbackslash allow}
\]
The retrieved value is written into \texttt{usbPolicyAllowFlag}, where a value of \texttt{1} disables all USB infection behavior.


The transition into the infection stage is therefore protected by a strict gate condition:

\begin{lstlisting}[language=C]
// Proceed ONLY if the USB is not marked AND the global kill-switch is not enabled
if ( *pUsbFlagStatus != 1 && usbPolicyAllowFlag != 1 )
{
    // ... core infection logic begins ...
}
\end{lstlisting}

This combination of per-device markers, host-level tracking, and a global policy ensures the malware avoids redundant infections, remains stealthy, and honors remote operator constraints.


\paragraph{Payload Staging and Persistence} \mbox{}\\
The malware initiates a multi-stage process to establish a hidden staging ground and synchronize its payload components.

The malware first ensures the existence of its installation directories:\\ \texttt{E:\textbackslash Firmware\textbackslash} and \texttt{E:\textbackslash Firmware\textbackslash vault\textbackslash}. To evade casual detection by users, it immediately modifies the file attributes of these directories using the API \texttt{SetFileAttributesW}.

As observed in the analysis, the malware pushes the argument \texttt{7} onto the stack before calling the API. This corresponds to the bitwise OR combination of:
\begin{itemize}
    \item \texttt{FILE\_ATTRIBUTE\_READONLY (0x1)}
    \item \texttt{FILE\_ATTRIBUTE\_HIDDEN (0x2)}
    \item \texttt{FILE\_ATTRIBUTE\_SYSTEM (0x4)}
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/createfirmware.png}
    \caption{The malware calls \texttt{SetFileAttributesW} with flag \texttt{0x7} on the root \texttt{Firmware} directory.}
    \label{fig:createfirmware}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/createfirmwarevault.png}
    \caption{The same hidden/system attributes are applied to the \texttt{vault} sub-directory.}
    \label{fig:createfirmwarevault}
\end{figure}

To further disguise the malicious directory as a legitimate system folder, the malware creates a \texttt{desktop.ini} file inside \texttt{E:\textbackslash Firmware\textbackslash}. Within this file, it embeds the CLSID, which corresponds to the Windows Explorer “Favorites” shell folder. By assigning this CLSID, the malware causes the directory to inherit the appearance and behavior of the Favorites folder, enhancing its stealth.


\textbf{Injected Configuration:}
\begin{lstlisting}
[.ShellClassInfo]
CLSID={323CA680-C24D-4099-B94D-446DD2D7249E}
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/createdesktopini.png}
    \caption{\texttt{desktop.ini} generation and CLSID construction.}
    \label{fig:createdesktopini}
\end{figure}


The malware employs a robust synchronization mechanism to copy its binaries (\texttt{aspex\_helper.exe}, \texttt{RBGUIFramework.dll}, and \texttt{aspex\_log.dat} files) to \texttt{E:\textbackslash Firmware\textbackslash vault\textbackslash}.

It iterates through the required files and performs the following logic:
\begin{enumerate}
    \item \textbf{Existence Check:} It calls \texttt{GetFileAttributesW} to check if the file already exists on the USB.
    \item \textbf{First-Time Infection:} If the function returns \texttt{-1} (File Not Found), the malware immediately copies the payload from the host to the USB.
    \item \textbf{Update Logic:} If the file exists and an internet connection is available, the malware compares the file on the USB against the copy on the compromised host:
    \begin{itemize}
        \item It checks if the file size has changed.
        \item It compares the file modification timestamps to determine if the host version is newer.
\end{itemize}
    If either condition is met (size mismatch or older timestamp), the malware deletes the existing file on the USB and replaces it with the newer version from the host.
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/copypayloadstofirmwarevault.png}
    \caption{ProcMon capture of malware copying binaries to the hidden vault.}
    \label{fig:copypayloads}
\end{figure}

\paragraph{Encrypted Beacon Logging (link.dat)} \mbox{}\\
In addition to the executable payloads, the malware manages a specific data file located at \texttt{E:\textbackslash Firmware\textbackslash vault\textbackslash link.dat}. Analysis of the internal function \texttt{AppendBeaconToLog} indicates that this file serves as a local, encrypted registry of infection "beacons" or unique identifiers.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/updatebeacontolog.png}
    \caption{Decompiled routine for appending encrypted beacons to link.dat.}
    \label{fig:updatebeacon}
\end{figure}

The malware utilizes a secure cycle to update this log:
\begin{enumerate}
    \item \textbf{Decryption \& Verification:} It reads the existing file and decrypts the content into memory using the function \texttt{mw\_xor\_buffer}. Notably, the encryption key is dynamic and derived directly from the data size:
    \begin{center}
        \texttt{key = length(buffer) + 1}
    \end{center}
    It then scans the decrypted data to ensure the current Beacon ID has not already been recorded.
    \item \textbf{Data Appending:} If the ID is unique, the malware appends the new beacon information to the end of the decrypted buffer.
    \item \textbf{Re-Encryption \& Update:} Finally, the expanded dataset is re-encrypted. Because the buffer size has increased, the key changes dynamically for this write operation, ensuring the log is always encrypted with a size-dependent key.
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/xorbuffer.png}
    \caption{The \texttt{mw\_xor\_buffer} routine.}
    \label{fig:xorbuffer}
\end{figure}

This mechanism ensures the malware maintains a comprehensive history of unique infections or sessions on the USB drive while preventing casual inspection of the data via static encryption.

\paragraph{Conditional Staging: "Information Volume"}\mbox{}\\
It is also worth noting that the malware exhibits a secondary file staging behavior contingent on internet connectivity.

If an active internet connection is detected, the malware initializes a directory on the USB drive named \texttt{Information Volume}. It then retrieves a subdirectory identifier from its internal configuration data. In the analyzed sample, this configuration value is set to ``\textbf{2}'', resulting in the target path:
\begin{center}
    \texttt{[USB]:\textbackslash Information Volume\textbackslash 2\textbackslash}
\end{center}

The malware subsequently attempts to copy its payloads from the host directory \\ \texttt{\%userprofile\%\textbackslash AspexHelperRMy\textbackslash} to this new location on the USB drive. 

\paragraph{WiFi Profile Synchronization}\mbox{}\\
The malware executes a conditional synchronization routine for WiFi configuration profiles (\texttt{.xml} files). The direction of data flow is determined by the infected host's internet connectivity status:

\begin{itemize}
    \item \textbf{Online Mode:} Exfiltrates profiles from the host's \texttt{\%TEMP\%\textbackslash WiFi} directory to the USB's hidden folder \texttt{\textbackslash Information Volume\textbackslash WiFi}.
    \item \textbf{Offline Mode:} Imports profiles from the USB drive to the host's \texttt{\%TEMP\%} directory.
\end{itemize}

This mechanism ensures that captured network credentials are propagated between infected air-gapped machines and internet-connected nodes.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/syncwifiprofiles.png}
    \caption{Exfiltrating WiFi profiles to USB (Online Mode).}
    \label{fig:wifisync}
\end{figure}

\paragraph{Final Infection Stage: Deception and Persistence}\mbox{}\\
Once the payload is staged, the malware executes its primary deception routine. This involves a specific trick to hide legitimate user data and replace it with a malicious entry point.

First, the malware creates a directory named with the Unicode character \texttt{0x200B} (Zero Width Space). Because this character is non-printing, the folder appears to have no name in Windows Explorer, and by applying hidden/system attributes, it becomes effectively invisible to the user.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/create0x200bfolder.png}
    \caption{Code execution creating the directory with the 0x200B name.}
    \label{fig:create0x200b}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/the0x200bfolderiscreated.png}
    \caption{The resulting invisible folder on the file system.}
    \label{fig:foldercreated}
\end{figure}

The infection flow is orchestrated through a precise sequence of file system manipulations:
\begin{enumerate}
    \item \textbf{Content Migration:} The malware moves all currently visible files and folders from the root of the USB drive into the hidden directory named with the Unicode zero-width space (\texttt{0x200B}).
    \item \textbf{Shortcut Generation:} Once the legitimate files are hidden, it generates a malicious LNK shortcut file in the root directory to serve as the deceptive entry point for the user.
\end{enumerate}

This process results in a visual swap. Where the user previously saw their documents, they now see only the malicious shortcut, which mimics the drive's volume name.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/usbbeforeinfection.png}
    \caption{Pre-infection: Visible user files.}
    \label{fig:beforeinfection}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/usbafterinfection.png}
    \caption{Post-infection: Only the malicious shortcut is visible.}
    \label{fig:afterinfection}
\end{figure}

The created shortcut is crafted to execute the malware payload while tricking the user. The target field points to the Windows Command Processor (\texttt{cmd.exe}) with specific arguments:

\begin{center}
    \texttt{\%comspec\% /c "\^{}Firmwa\^{}re\textbackslash vault\textbackslash aspex\_helper.exe rand1 rand2"}
\end{center}

\textbf{Technical Details:}
\begin{itemize}
    \item \textbf{Obfuscation:} The caret symbols (\texttt{\^{}}) are used to break string-based detection signatures (e.g., \texttt{\^{}Firmwa\^{}re} resolves to \texttt{Firmware}).
    \item \textbf{Execution Logic:} The malware is launched with two random arguments (\texttt{rand1 rand2}). This ensures the application starts with \texttt{argc = 3}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/maliciousshortcut.png}
    \caption{Shortcut properties showing the obfuscated target path.}
    \label{fig:maliciousshortcut}
\end{figure}

\subsubsection{Execution Flow: The Deception Routine (Case Argc = 3)}

When a victim unknowingly clicks the malicious shortcut on the infected USB drive, the malware is executed via \texttt{cmd.exe} with two random arguments, as defined during the infection phase.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/logthatshowexecutetheshortcut.png}
    \caption{Process log showing the malware executing with 2 random arguments.}
    \label{fig:shortcutexecution}
\end{figure}

This execution triggers the \texttt{Case 3} logic within the malware's main argument switch (since \texttt{argc} includes the executable name plus two arguments). The primary goal of this routine is to maintain the illusion that the user has successfully opened their USB drive, while concealing the fact that the malware is now running.

The malware immediately constructs the path to the hidden directory containing the user's legitimate data (e.g., \texttt{E:\textbackslash[0x200B]\textbackslash}). It then invokes \texttt{ShellExecuteW} with the \texttt{"open"} verb.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/refreshexplorer.png}
    \caption{ShellExecuteW call opening the hidden folder.}
    \label{fig:shellexecute}
\end{figure}

To the user, the resulting window appears indistinguishable from the root of the drive. As shown below, the Explorer window displays the user's files (\texttt{doc} folder), successfully deceiving the victim.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/onopentheshortcut.png}
    \caption{The malware opens the hidden folder, presenting legitimate files to the user.}
    \label{fig:onopentheshortcut}
\end{figure}

To complete the illusion, the malware must close the original Explorer window (the root of the USB drive containing the malicious shortcut) so the user does not navigate back to it.

It achieves this by searching for the active Windows Explorer window using the class name \\ \texttt{"CabinetWClass"} via \texttt{FindWindowW}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/findwindow.png}
    \caption{Locating the active Explorer window via CabinetWClass.}
    \label{fig:findwindow}
\end{figure}

Once the window handle is retrieved, the malware sends a \texttt{WM\_CLOSE} message (Decimal \texttt{16} / Hex \texttt{0x10}) to that window using the \texttt{SendMessageW} API. This forces the window to close immediately, leaving only the newly opened "Decoy" window (the hidden folder) visible on the screen.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/sendmessage.png}
    \caption{Sending WM\_CLOSE (16) to terminate the previous window.}
    \label{fig:sendmessage}
\end{figure}

\subsubsection{Thread 2: Manage USB Data Theft}

The second worker thread is responsible for the bi-directional transfer of data between the infected USB drive and the compromised host. As illustrated in the decompiled code, the direction of this transfer is entirely dependent on the host's current internet connectivity status.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/usbthread2.png}
    \caption{Decompiled code of the thread Manage USB Data Theft}
    \label{fig:usbthread2}
\end{figure}

\paragraph{Targeting Criteria: File Selection Filters} \mbox{}\\
Regardless of the connectivity status, the data theft routine enforces specific filtering criteria derived from the malware's configuration data to identify files of interest. The selection logic relies on three numeric values found in its config data:

\begin{enumerate}
    \item \textbf{File Type Bitmask:} The malware utilizes a specific configuration byte (offset \texttt{0x788CC}) set to \texttt{0x7F} (Binary \texttt{01111111}) as a bitmask to target specific file extensions. This mapping prioritizes sensitive office documents:
    \begin{itemize}[noitemsep]
        \item \textbf{Bit 1 (0x01):} \texttt{.doc}
        \item \textbf{Bit 2 (0x02):} \texttt{.docx}
        \item \textbf{Bit 3 (0x04):} \texttt{.xls}
        \item \textbf{Bit 4 (0x08):} \texttt{.xlsx}
        \item \textbf{Bit 5 (0x10):} \texttt{.ppt}
        \item \textbf{Bit 6 (0x20):} \texttt{.pptx}
        \item \textbf{Bit 7 (0x40):} \texttt{.pdf}
    \end{itemize}
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=1.0\textwidth]{images/targetfiletypebitmask.png}
        \caption{Configuration byte defining the target file types (0x7F).}
        \label{fig:targetbitmask}
    \end{figure}

    \item \textbf{Recency Threshold:} A second configuration value (offset \texttt{0x788D8}), set to \textbf{30}, enforces a temporal limit. The malware calculates the difference between the current system time and the file's last write time, ensuring only files modified within the last 30 days are collected.
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=1.0\textwidth]{images/targetfilerecentlyday.png}
        \caption{Configuration value setting the recency limit to 30 days.}
        \label{fig:targetrecency}
    \end{figure}

    \item \textbf{Size Constraint:} A third configuration value (offset \texttt{0x788E0}), currently set to \textbf{0}, defines the maximum file size for exfiltration. In this sample, the value 0 implies that no size restriction is applied.
    
    \begin{figure}[H]
        \centering
        \includegraphics[width=1.0\textwidth]{images/targetfilesizelimit.png}
        \caption{Configuration value setting the size limit (0 = Unlimited).}
        \label{fig:targetsizelimit}
    \end{figure}
\end{enumerate}

\paragraph{Scenario A: Internet Available (Import to Host)} \mbox{}\\
If the compromised host has an active internet connection, the malware assumes the role of a "collection point." It executes \texttt{mw\_import\_usb\_files\_to\_host} to harvest data previously staged on the USB drive and consolidates it on the connected host.

The routine performs the following actions:
\begin{enumerate}
    \item \textbf{Beacon Retrieval:} It attempts to copy the encrypted log file \texttt{E:\textbackslash Firmware\textbackslash vault\textbackslash link.dat} to the host.
    \item \textbf{Data Harvesting:} It searches for specific directories on the USB drive, including:
    \begin{itemize}
        \item \texttt{\textbackslash Information Volume\textbackslash 2}
        \item \texttt{\textbackslash Information Volume\textbackslash 2\textbackslash p}
        \item \texttt{\textbackslash Information Volume\textbackslash 2\textbackslash p2}
        \item \texttt{\textbackslash System Volume Information}
    \end{itemize}
\end{enumerate}

Any matching content found is copied to the host's staging directory located at:
\begin{center}
    \texttt{\%AppData\%\textbackslash Roaming\textbackslash Document\textbackslash}
\end{center}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/log_that_show_mw_import_usb_files_to_host.png}
    \caption{ProcMon log showing data transfer from USB to AppData.}
    \label{fig:importlog}
\end{figure}

\paragraph{Scenario B: No Internet (Initialize Staging \& Exfiltrate)} \mbox{}\\
If the host is offline, the malware switches behavior to treat the USB drive as a "mule" for data exfiltration. It first prepares the USB drive by calling \texttt{mw\_initialize\_usb\_staging\_env}.

This initialization routine ensures the existence of the directory structure \texttt{E:\textbackslash Information Volume\textbackslash 2\textbackslash}. To conceal these folders, it sets their file attributes to \texttt{0x7} (Read-Only | Hidden | System).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/setfileattributes_information__volume.png}
    \caption{Hiding the root "Information Volume" folder (Attr: 0x7).}
    \label{fig:hideinfovol}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/setfileattributes_information_volume_2.png}
    \caption{Hiding the sub-directory "2" (Attr: 0x7).}
    \label{fig:hideinfovol2}
\end{figure}

Furthermore, to disguise the folder structure as a system artifact, the malware creates a \texttt{desktop.ini} file inside \texttt{Information Volume\textbackslash 2\textbackslash} injected with a specific Class ID:
\begin{center}
    \texttt{CLSID=\{88C6C381-2E85-11D0-94DE-444553540000\}}
\end{center}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/create_desktop_ini_information_volume_2.png}
    \caption{Decompiled code showing CLSID injection into desktop.ini.}
    \label{fig:createdesktopini2}
\end{figure}

\paragraph{Host Reconnaissance and Exfiltration}\mbox{}\\
Following the initialization of the hidden staging directory, the malware executes a reconnaissance routine to harvest detailed system information from the compromised host. This process is orchestrated through a dynamically generated batch script.

The malware constructs a temporary batch file path (e.g., \texttt{tmp\_3970tmp.bat}) within the user's \texttt{\%TEMP\%} directory. It then writes a sequence of Windows command-line instructions into this file.

Crucially, the output filenames for these commands are not random. The malware retrieves a unique identifier string (e.g., \texttt{3F946C3D}) directly from its configuration data and uses it to construct the target filenames (e.g., \texttt{3F946C3D8DDD0EBA\_E.dat}). As shown previously in Figure~\ref{fig:host_fingerprinting}, this identifier helps link data to the specific infection.

Notably, the suffix appended to the filename (e.g., \texttt{\_E}) corresponds directly to the drive letter of the infected USB device. This naming convention allows the attacker to identify the specific propagation source for the exfiltrated data.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/construct_and_write_to_tmpbat_recon_cmd.png}
    \caption{Code constructing the reconnaissance batch script using the Config ID.}
    \label{fig:constructbat}
\end{figure}

The content of the generated batch file is as follows:

\begin{lstlisting}[language=Verilog, caption=Reconnaissance Batch Script Content]
%comspec% /q /c systeminfo >%~dp0[Config_ID]_[Suffix].dat
%comspec% /q /c ipconfig /all >>%~dp0[Config_ID]_[Suffix].dat
%comspec% /q /c netstat -ano >>%~dp0[Config_ID]_[Suffix].dat
%comspec% /q /c arp -a >>%~dp0[Config_ID]_[Suffix].dat
%comspec% /q /c tasklist -v >>%~dp0[Config_ID]_[Suffix].dat
del %0
\end{lstlisting}

\begin{itemize}
    \item \textbf{Output Redirection:} The output of each command is redirected (or appended) to the uniquely named data file located in the same directory.
    \item \textbf{Self-Deletion:} The final command \texttt{del \%0} ensures the batch script deletes itself immediately after execution to minimize forensic footprints.
\end{itemize}

\textbf{Execution and Collection} \mbox{}\\
The malware executes the script using \texttt{cmd.exe}. As shown in the process tree below, the parent malware process spawns the command processor, which in turn launches standard Windows utilities (\texttt{systeminfo}, \texttt{ipconfig}, etc.).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/log_that_show_the_recon_is_running.png}
    \caption{Process tree capturing the execution of reconnaissance commands.}
    \label{fig:reconexecution}
\end{figure}

The result is a plaintext file containing comprehensive system details.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/recon_result.png}
    \caption{The raw output file containing system information.}
    \label{fig:reconresult}
\end{figure}

Once the data is captured, the malware reads the plaintext result file and encrypts its content using the \texttt{mw\_xor\_buffer} routine. Consistent with the encryption logic observed in the logging module, the key is dynamically derived from the data size.

\begin{center}
    \texttt{key = length(buffer) + 1}
\end{center}

The encrypted data is then saved to the hidden exfiltration folder on the USB drive.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/write_encrypted_recond_result_to_file_using_some_id_in_config_data.png}
    \caption{Writing the encrypted reconnaissance data to the hidden USB folder.}
    \label{fig:writetousb}
\end{figure}

Finally, to clean up its tracks on the host, the malware deletes the local temporary file containing the plaintext reconnaissance data.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/delete_recon_result_on_host.png}
    \caption{Debug showing the deletion of the local reconnaissance file.}
    \label{fig:deleterecon}
\end{figure}

\paragraph{System-Wide Targeted Exfiltration to USB} \mbox{}\\
Once the reconnaissance data is secured, the malware begins the actual theft of user documents. This process occurs in distinct phases, all relying on the previously defined targeting criteria (File Type Bitmask, Recency, and Size) to filter content.

\textbf{Phase 1: Known Directory Collection} \\
The malware first targets specific, hardcoded directory paths on the compromised host that are highly likely to contain user data. It directly invokes the exfiltration routine \texttt{mw\_import\_host\_files\_to\_usb} against:
\begin{itemize}
    \item \texttt{\%ALLUSERSPROFILE\%\textbackslash Internet\textbackslash} (e.g., \texttt{C:\textbackslash ProgramData\textbackslash Internet\textbackslash})
    \item \texttt{\%USERPROFILE\%\textbackslash} (e.g., \texttt{C:\textbackslash Users\textbackslash [Username]\textbackslash})
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/import_host_files_from_known_directories_to_usb.png}
    \caption{Targeting specific user and program data directories for exfiltration.}
    \label{fig:targetdirs}
\end{figure}

\textbf{Phase 2: Full Drive Enumeration} \\
Following the targeted collection, the malware attempts to scour the rest of the system. It utilizes a \texttt{do-while} loop to iterate through all mounted volumes on the host.

For each detected volume, the malware checks the drive type. If the drive is determined to be a fixed disk (and not the USB destination itself), the malware initiates a recursive crawl of that drive. Any file encountered during this scan that matches the "files of interest" criteria is immediately copied to the hidden staging folder on the USB drive.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/continuously_scan_for_non_usb_drive_to_import_to_usb.png}
    \caption{Looping through non-USB volumes to steal eligible files.}
    \label{fig:driveenum}
\end{figure}

\textbf{Phase 3: Filename Obfuscation (Base64)} \\
A distinct characteristic of the exfiltration process is the obfuscation of filenames on the destination drive. When a file is stolen, its original name is not preserved in plaintext. Instead, the malware encodes the original filename using \textbf{Base64}.

As seen in the Process Monitor log below, the malware reads the source file \texttt{doc\textbackslash test.docx} and writes it to the USB drive using the filename \texttt{ZG9jX3Rlc3QuZG9jeA==}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/log_that_show_it_steal_file_and_create_base64_encoded_file_to_usb.png}
    \caption{ProcMon capture: Read \texttt{doc\textbackslash test.docx} $\rightarrow$ Write \texttt{ZG9jX3Rlc3QuZG9jeA==}.}
    \label{fig:procmonsteal}
\end{figure}

This results in a directory listing on the USB drive composed entirely of Base64 strings, further obfuscating the nature of the stolen data to a casual observer.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/base64_encoded_path_of_stole_files.png}
    \caption{The exfiltration directory populated with Base64 encoded filenames.}
    \label{fig:base64dir}
\end{figure}

Decoding these strings confirms the mapping to the original user files.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/encode64_path_name.png}
    \caption{Decoding the artifact confirms the original filename.}
    \label{fig:decodebase64}
\end{figure}


\subsubsection{Thread 3: Offline Batch Script Execution}

The third worker thread functions as a fallback command channel. Before executing its payload logic, the thread attempts to validate an internal condition by querying the registry value:
\begin{center}
    \texttt{HKCU\textbackslash System\textbackslash CurrentControlSet\textbackslash Control\textbackslash Network\textbackslash proxy}
\end{center}

Analyst Note: This is not a standard Windows registry key for proxy configurations. It appears to be a malware-defined artifact—likely a flag set by the attacker or a previous infection stage—used to conditionally enable or disable this specific thread's execution (a custom "kill-switch"). The thread proceeds only if this value is not set to "1".

Upon passing this check, the malware scans the USB target directory \texttt{[Drive]:\textbackslash Information Volume\textbackslash 2\textbackslash p\textbackslash} for batch files (\texttt{.bat}).

\textbf{Experimental Observation:}
To observe this behavior during dynamic analysis, a test payload named \texttt{hello.bat} was manually placed in the target directory on the simulated USB drive. The malware successfully detected this file, triggering the execution chain.

The execution flow involves reading the batch file, decrypting it using a dynamic XOR key (derived from the file size), and writing the content to a randomly named file in the host's \texttt{\%TEMP\%} directory. As captured in the Process Monitor log below, the malware then executes this temporary script.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/log_that_show_it_prepare_tmp_bat_in_temp.png}
    \caption{ProcMon log showing the creation and execution of the temporary batch file.}
    \label{fig:executebat}
\end{figure}

Following execution, the malware performs a cleanup routine, deleting both the original file from the USB and the temporary artifact from the host. This behavior suggests the thread is designed to execute encrypted batch scripts dropped onto the USB during a physical access event.


\subsubsection{WiFi Credential Harvesting and Connectivity Restoration}

The malware implements a dedicated persistence mechanism to harvest wireless network credentials and actively restore internet connectivity if the compromised host goes offline. This logic is managed by a worker thread that wakes up every 2 minutes to execute the harvesting routine.

\paragraph{Credential Staging and Theft} \mbox{}\\
Upon execution, the malware prepares a hidden staging directory at \texttt{\%TEMP\%\textbackslash WiFi}. It explicitly hides this folder by setting the \texttt{FILE\_ATTRIBUTE\_HIDDEN} flag.

To harvest credentials, the malware invokes the Windows \texttt{netsh} utility. Crucially, it uses the \texttt{key=clear} argument, forcing Windows to dump the saved WiFi passwords in plaintext within the output XML files.

\begin{verbatim}
cmd.exe /c netsh wlan export profile key=clear folder="%TEMP%\WiFi"
\end{verbatim}

\paragraph{Connectivity Restoration Logic} \mbox{}\\
After exporting the profiles, the malware checks the host's internet connection status. If the host is offline, it iterates through the exported XML files to find a known network that is currently within range.

\begin{figure}[H]
    \centering
    \captionsetup{list=yes}
    \includegraphics[width=1.0\textwidth]{images/mw_connect_to_wifi_using_exported_profiles_try_to_connect_with_each_profile.png}
    \caption[]{Logic iterating through exported profiles to attempt reconnection.}
    \label{fig:iterate_profiles}
\end{figure}
To perform this network discovery without alerting the user, the malware creates an anonymous pipe and spawns a child process to list all currently visible wireless networks. It uses `find "SSID"` to filter the output, ensuring it captures the names of all nearby access points.

\begin{verbatim}
%comspec% /c netsh wlan show networks | find "SSID"
\end{verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/scan_for_nearby_wifi.png}
    \caption[]{Executing netsh via anonymous pipes to list all visible SSIDs.}
    \label{fig:scan_wifi}
\end{figure}

The malware reads this aggregate list from the pipe and then internally searches the buffer (using string comparison functions like \texttt{wcsstr}) to determine if the specific SSID from the target XML profile is present.

If the network is found, the malware executes a sequence of three commands to forcibly reset the wireless interface and connect using the stolen credentials:

\begin{verbatim}
:: 1. Disconnect from any current access point
%comspec% /c netsh wlan disconnect

:: 2. Re-import the profile (restoring the plaintext key)
%comspec% /c netsh wlan add profile filename="[Path_To_Profile.xml]"

:: 3. Initiate the connection
%comspec% /c netsh wlan connect name="[Profile_Name]"
\end{verbatim}


\subsubsection{Command and Control (C2) Communication}

Following the infection and local data harvesting routines, the malware initiates its primary Command and Control (C2) module, \texttt{mw\_c2\_main}. This module is responsible for establishing a secure channel with the attacker, receiving tasks, and exfiltrating collected data.

\paragraph{Anti-Debugging Measures}\mbox{}\\
Upon entering the C2 routine, the malware immediately creates a dedicated thread to protect itself from dynamic analysis. The function \texttt{mw\_c2\_main} resolves the address of \texttt{CreateThread} and spawns \texttt{mw\_thread\_check\_debugger}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/create_antidebug_thread_and_then_invok_c2main.png}
    \caption{Creation of the anti-debugging thread prior to C2 execution.}
    \label{fig:antidebug_thread}
\end{figure}

The \texttt{mw\_thread\_check\_debugger} function executes an infinite loop that periodically invokes the Windows API \texttt{CheckRemoteDebuggerPresent}.
\begin{itemize}
    \item It checks if the current process is being debugged.
    \item If a debugger is detected (return value is 1), the thread breaks the loop and immediately terminates the malware process, thereby preventing further analysis.
    \item If no debugger is found, it sleeps for 1,000 milliseconds (1 second) before repeating the check.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/mw_thread_check_debugger.png}
    \caption{The dedicated thread continuously polling for debuggers.}
    \label{fig:check_debugger_code}
\end{figure}

\paragraph{Connectivity Check and Decoy Traffic}\mbox{}\\
Before attempting to connect to its actual C2 server, the malware performs a connectivity check that doubles as a camouflage technique. It constructs a request to a legitimate, high-reputation domain to test internet access and blend in with normal background traffic.

As seen in the decompiled code, the malware obfuscates the target string. At runtime, this string resolves to \texttt{www.microsoft.com}. The malware configures the port to \textbf{443} (HTTPS) and calls \texttt{mw\_try\_to\_communicate\_with\_server}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/mw_c2_main_get_request_to_ms.png}
    \caption{Targeting www.microsoft.com as a decoy connectivity check.}
    \label{fig:decoy_microsoft}
\end{figure}

Following the decoy check, the malware enters a loop that iterates through each of the three C2 profiles extracted from its configuration data, as shown previously in Figure~\ref{fig:c2_config_addresses}. For each profile, it attempts to establish a connection to the specified server using the \\ \texttt{mw\_try\_to\_communicate\_with\_server} function.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/for_each_c2_profile_in_config.png}
    \caption{Looping through the 3 C2 profiles and attempting connection.}
    \label{fig:c2_profile_loop}
\end{figure}

The communication wrapper, \texttt{mw\_try\_to\_communicate\_with\_server}, enters a persistent \texttt{while(1)} loop to initiate the connection via \texttt{mw\_start\_communication}.

The loop logic is governed by the return value of \texttt{mw\_start\_communication}. Since this function blocks during an active session, a return value implies the session has ended.

The malware handles the reconnection logic as follows:
\begin{enumerate}
    \item \textbf{Error Tracking:} If the connection attempt fails (result is non-zero), the malware increments an internal error counter located at \texttt{this[3]}.
    \item \textbf{Threshold Check:} The code immediately checks if this counter has reached \textbf{3}. If so, it explicitly terminates the loop (\texttt{break}) to abandon the current C2 profile.
    \item \textbf{Global Termination Check:} Regardless of the error counter, the malware checks the global state variable \texttt{gb\_isc2alive}.
    \begin{itemize}
        \item If this value equals \textbf{4}, the function returns the error code immediately, effectively aborting all communication attempts.
    \end{itemize}
    \item \textbf{Retry Delay:} If neither termination condition is met (and an error occurred), the malware sleeps for 2,000 milliseconds (2 seconds) before re-attempting the connection.
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/mw_try_to_conmmunicate_with_server.png}
    \caption{Loop attempting to establish connection.}
    \label{fig:communication_loop}
\end{figure}

\paragraph{Session Initialization and Environment Fingerprinting}\mbox{}\\
The function \texttt{mw\_start\_communication} is responsible for configuring the HTTP session. This involves two critical steps: masquerading as a legitimate browser via a custom User-Agent and adhering to the victim's proxy settings.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.70\textwidth]{images/mw_start_communication_init.png}
    \caption{Initialization of User-Agent and Proxy settings before WinHttpOpen.}
    \label{fig:start_comm_init}
\end{figure}

\paragraph{Dynamic User-Agent Generation}\mbox{}\\
To evade network-based signatures that flag generic or hardcoded User-Agent strings, the malware dynamically constructs a string that mimics Internet Explorer running on the specific victim host. The format used is:

\begin{center}
\texttt{Mozilla/5.0 (compatible; MSIE \{1\}; Windows NT \{2\}.\{3\}; \{4\}; \{5\}; \{6\}; \{7\})}
\end{center}

The placeholders \texttt{\{1\}} through \texttt{\{7\}} are populated by querying specific Windows Registry keys to gather system information:

\begin{table}[H]
\centering

\label{tab:user_agent_placeholders}
\begin{tabularx}{\textwidth}{@{}c X@{}}
\toprule
\textbf{ID} & \textbf{Data Source / Registry Key} \\ \midrule
\{1\} & \textbf{IE Version} \newline Derived from: \newline \seqsplit{HKEY\_LOCAL\_MACHINE\textbackslash SOFTWARE\textbackslash Microsoft\textbackslash Internet Explorer\textbackslash Version Vector\textbackslash IE} \newline (Defaults to '8.00' if not found). \\ \addlinespace
\{2\} & \textbf{OS Major Version} of the host. \\ \addlinespace
\{3\} & \textbf{OS Minor Version} of the host. \\ \addlinespace
\{4\} & \textbf{System Post Platform (5.0)} \newline Concatenated values from: \newline \seqsplit{HKEY\_LOCAL\_MACHINE\textbackslash SOFTWARE\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Internet Settings\textbackslash 5.0\textbackslash User Agent\textbackslash Post Platform} \\ \addlinespace
\{5\} & \textbf{Machine Post Platform} \newline Concatenated values from: \newline \seqsplit{HKEY\_LOCAL\_MACHINE\textbackslash SOFTWARE\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Internet Settings\textbackslash User Agent\textbackslash Post Platform} \\ \addlinespace
\{6\} & \textbf{User Post Platform (5.0)} \newline Concatenated values from: \newline \seqsplit{HKEY\_CURRENT\_USER\textbackslash Software\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Internet Settings\textbackslash 5.0\textbackslash User Agent\textbackslash Post Platform} \\ \addlinespace
\{7\} & \textbf{User Post Platform} \newline Concatenated values from: \newline \seqsplit{HKEY\_CURRENT\_USER\textbackslash Software\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Internet Settings\textbackslash User Agent\textbackslash Post Platform} \\
\bottomrule
\end{tabularx}
\caption{Dynamic User-Agent Placeholder Mapping}
\end{table}

\paragraph{Proxy Configuration}\mbox{}\\
To ensure the malware can communicate even in corporate environments protected by proxy servers, it executes \texttt{mw\_load\_proxy\_setting\_config}. This function queries the Windows Registry at:

\texttt{HKEY\_CURRENT\_USER\textbackslash Software\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Internet Settings}

It specifically checks two values:
\begin{itemize}
    \item \textbf{ProxyEnable:} Checked to determine if a proxy is currently active (\texttt{1} = active).
    \item \textbf{ProxyServer:} Read to retrieve the actual proxy address and port.
\end{itemize}

These gathered settings—the custom User-Agent string and the Proxy configuration—are passed to the \texttt{WinHttpOpen} API, initializing the session that will be used for the subsequent C2 traffic.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/mw_start_communication_connection.png}
    \caption{The C2 communication loop invoking the HTTP connection handler.}
    \label{fig:c2_connection_loop}
\end{figure}

\paragraph{Initial Handshake and Key Retrieval} \mbox{}\\
Upon establishing a connection to the C2 server, the execution flow enters the \\ \texttt{mw\_http\_connection\_handler}. The primary objective of this phase is to perform an initial handshake to retrieve a session-specific encryption key from the server.

The handler first constructs an obfuscated string which resolves to the HTTP verb \textbf{"GET"}. It then invokes the function \texttt{mw\_retrieve\_key}, passing the session handle and the URI.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{images/mw_http_connection_handler_retrieve_key.png}
    \caption{The handler invoking \texttt{mw\_retrieve\_key} using a GET request.}
    \label{fig:retrieve_key_call}
\end{figure}


\paragraph{Transition to Main C2 Loop}\mbox{}\\
If the GET request is successful and the server responds with valid data, the function returns a non-zero length for the retrieved string object. This response contains the encryption key required for subsequent communications.

The malware allocates memory for this key and stores it for later use. Once the key is secured, the protocol switches the HTTP verb to \textbf{"POST"} and calls \texttt{mw\_c2handle}. This function represents the main Command and Control routine, where the malware begins its check-in loop and task processing.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/mw_http_connection_handler_retrieve_key_success.png}
    \caption{Successful key retrieval leading to the execution of \texttt{mw\_c2handle}.}
    \label{fig:key_success_c2handle}
\end{figure}

\paragraph{Custom Header Construction (X-Oss-Request-Id)}\mbox{}\\
Inside the \texttt{mw\_retrieve\_key} function, the malware constructs a specific custom HTTP header to embed in the request. This header, \texttt{X-Oss-Request-Id}.

The header value follows the format \texttt{\%2.2X\%ws} and is generated using two specific routines:
\begin{enumerate}
    \item \textbf{Random ID Generation:} The malware calls \texttt{mw\_generate\_random\_number}, which utilizes the high-resolution timer \texttt{QueryPerformanceCounter} to generate a seed. It adds \textbf{100} to this value to ensure a specific numeric range.
    \item \textbf{Checksum-Based String:} It calls \texttt{mw\_GenerateStringFromChecksum} with the argument \textbf{99}. This function generates a random alphanumeric string that mathematically satisfies a specific checksum algorithm, serving as a validity check for the server.
\end{enumerate}

These components are formatted into the header string using \texttt{wsprintfW} before the request is dispatched.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/mw_retrieve_key_construct_X-Oss-Request-Id_header.png}
    \caption{Construction of the \texttt{X-Oss-Request-Id} header using dynamic values.}
    \label{fig:header_construction}
\end{figure}

The malware then passes this constructed header to \texttt{mw\_perform\_request} to transmit the packet to the C2 server.

It is important to note that the checksum argument passed to \texttt{mw\_GenerateStringFromChecksum} serves as a specific indicator of the request type to the C2 server.

\begin{itemize}
    \item \textbf{GET Requests (Key Retrieval):} As described in the key retrieval routine above, the malware uses the argument \textbf{99} to generate the validation string.
    \item \textbf{POST Requests (Data Transmission):} For subsequent POST requests used to upload data or receive tasks, the malware switches the argument to \textbf{88}.
\end{itemize}

This differentiation likely allows the server to quickly categorize incoming traffic based solely on the algorithmic properties of the \texttt{X-Oss-Request-Id} header.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\textwidth]{images/xossrequestid_header_for_post_request_use_checksum88.png}
    \caption{Generation of the X-Oss-Request-Id header for POST requests using checksum 88.}
    \label{fig:post_header_checksum}
\end{figure}

\paragraph{Request Initialization}\mbox{}\\
The malware initiates the request using \texttt{WinHttpOpenRequest}. Notably, the code explicitly passes \texttt{0} (NULL) for both the \texttt{pwszObjectName} (Object Name) and \texttt{pwszVersion} (HTTP Version) parameters.

By default, this forces the API to request the root path using HTTP/1.1. Consequently, all C2 traffic generated by this malware will appear on the wire with the following request lines, regardless of the specific C2 server file structure:
\begin{center}
    \texttt{GET / HTTP/1.1} \quad or \quad \texttt{POST / HTTP/1.1}
\end{center}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/mw_perform_request_WinHTTPOpenRequest.png}
    \caption{WinHttpOpenRequest called with NULL parameters, resulting in generic request paths.}
    \label{fig:winhttp_request}
\end{figure}

\paragraph{Timeout Configuration}\mbox{}\\
To ensure connection stability, particularly when operating on slow or unstable networks, the malware overrides the default Windows HTTP timeouts. It retrieves a configuration value stored in the global variable \texttt{gb\_timeout\_settings} (extracted earlier from the config data) and applies it to the session.

In the analyzed sample, these timeouts are set to \textbf{60,000 ms (60 seconds)} for the following operations:
\begin{itemize}
    \item \texttt{WINHTTP\_OPTION\_CONNECT\_TIMEOUT}
    \item \texttt{WINHTTP\_OPTION\_RECEIVE\_TIMEOUT}
    \item \texttt{WINHTTP\_OPTION\_SEND\_TIMEOUT}
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{images/http_relay.png}
    \caption{Setting connection, receive, and send timeouts to 60 seconds.}
    \label{fig:http_timeouts}
\end{figure}

\paragraph{SSL/TLS Security Configuration}\mbox{}\\
The malware communicates with its C2 server over HTTPS. Recognizing that the attacker infrastructure often utilizes self-signed or otherwise invalid SSL certificates, the malware explicitly relaxes standard security checks to prevent connection errors.

If SSL is enabled, the code applies the flag \texttt{0x3300} using \texttt{WinHttpSetOption}. This value corresponds to a bitwise combination of flags that instruct the client to ignore specific certificate errors:
\begin{itemize}
    \item \texttt{WINHTTP\_FLAG\_IGNORE\_UNKNOWN\_CA}
    \item \texttt{WINHTTP\_FLAG\_IGNORE\_CERT\_CN\_INVALID} (Hostname mismatch)
    \item \texttt{WINHTTP\_FLAG\_IGNORE\_CERT\_DATE\_INVALID} (Expired certificate)
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/https_config.png}
    \caption{Applying security flags (0x3300) to ignore SSL certificate errors.}
    \label{fig:ssl_config}
\end{figure}

\paragraph{Custom Header Injection (X-Cache)}\mbox{}\\
Finally, the malware injects a custom HTTP header named \texttt{X-Cache} into every request. This header serves as a secondary authentication mechanism and transmits the victim's unique identity to the C2 server.

The header value is dynamically constructed using the format:
\begin{center}
    \texttt{X-Cache: \{Rand1\}\{Rand2\}\{VictimID\}}
\end{center}

\begin{itemize}
    \item \textbf{\{Rand1\} \& \{Rand2\}:} Two randomly generated hex strings (2 characters each).
    \item \textbf{\{VictimID\}:} The persistent 16-character unique identifier generated during the Host Fingerprinting phase (refer to Figure \ref{fig:host_fingerprinting} and the variable \texttt{gb\_victim\_id}).
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/xcacheheader.png}
    \caption{Construction of the custom X-Cache header embedding the Victim ID.}
    \label{fig:xcache_header}
\end{figure}

\paragraph{Response Header Validation and Processing}\mbox{}\\
Upon receiving a response from the C2 server, the malware does not immediately process the payload. Instead, it performs a strict validation of the HTTP headers to ensure the response is legitimate and intended for this specific implant.

The malware first queries the \texttt{Content-Type} header using \texttt{WinHttpQueryHeaders} with the flag \texttt{WINHTTP\_QUERY\_CONTENT\_TYPE}.

It strictly validates that this value matches the string \texttt{"application/octet-stream"}. As seen in the decompiled logic, the code uses \texttt{lstrcmpiW} to compare the retrieved header against this hardcoded string.
\begin{itemize}
    \item \textbf{Match:} If the strings match (return value 0), execution proceeds.
    \item \textbf{Mismatch:} If the Content-Type is anything else (e.g., \texttt{text/html}), the code immediately jumps to the cleanup routine and aborts the connection.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/WinHttpQueryHeaders_WINHTTP_QUERY_CONTENT_TYPE.png}
    \caption{Querying the Content-Type header from the server response.}
    \label{fig:query_content_type}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/must_contain_application_octet_stream_in_response_header.png}
    \caption{Enforcing that the Content-Type must be "application/octet-stream".}
    \label{fig:validate_content_type}
\end{figure}

When the C2 server intends to deliver a file (e.g., a plugin or update), it includes a custom \texttt{filename} parameter within the HTTP headers. To retrieve this, the malware cannot use a standard flag; instead, it requests the entire header block using \texttt{WINHTTP\_QUERY\_RAW\_HEADERS\_CRLF}.

This API call returns all returned headers as a single string. The malware then parses this raw data to locate the \texttt{"filename"} directive and extract the target file name.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/WinHttpQueryHeaders_WINHTTP_QUERY_RAW_HEADERS_CRLF.png}
    \caption{Retrieving the full raw headers to parse the custom "filename" parameter.}
    \label{fig:query_raw_headers}
\end{figure}


\paragraph{Packet Structure}\mbox{}\\
The malware constructs a header containing metadata, followed by the victim's identification string, and finally the actual payload data. Based on the analysis of the underlying structure, the packet format is defined as follows:

\begin{table}[H]
\centering
\caption{C2 Packet Structure (Pre-Encryption)}
\label{tab:packet_structure}
\begin{tabularx}{\textwidth}{@{}l l X@{}}
\toprule
\textbf{Offset} & \textbf{Size} & \textbf{Description} \\ \midrule
0x00 & 2 bytes & \textbf{Transaction ID}: A random value generated to uniquely identify the request and prevent replay attacks. \\
0x02 & 2 bytes & \textbf{Command ID}: Indicates the type of data or operation being conveyed in the packet. \\
0x04 & 4 bytes & \textbf{Payload Size}: The total size of the data section that follows the header. \\
0x08 & 8 bytes & \textbf{Reserved}: Padding fields initialized to zero. \\
0x10 & 32 bytes & \textbf{Beacon ID}: The unique fingerprint of the compromised host. \\
0x30 & Variable & \textbf{Data Payload}: The actual operational data, which varies depending on the mode. \\
\bottomrule
\end{tabularx}
\end{table}

\paragraph{Payload Selection Logic}\mbox{}\\
The packet construction logic operates in one of two distinct modes, dictating the content of the Data Payload section:

\begin{itemize}
    \item \textbf{Heartbeat Mode:} In this mode, the malware initiates an internal routine to aggregate comprehensive system and session details. As confirmed by the code analysis (Figure~\ref{fig:gather_info}), this includes the Operating System version, CPU architecture (specifically checking for WOW64 execution), the current User Name and Computer Name, the name of the executing process, the malware's internal version string, and a list of local IP addresses. This fingerprinting data is formatted into a payload buffer to provide the C2 server with a detailed status update.
    \item \textbf{Task Response Mode:} This mode is used when the malware needs to return data resulting from a specific task (e.g., the output of a shell command, a file listing, or exfiltrated data). The routine takes a raw data buffer containing these results and wraps it as the payload.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/gatherinformation.png}
    \caption{Decompiled routine showing the aggregation of system information in heartbeat mode.}
    \label{fig:gather_info}
\end{figure}

\paragraph{Packet Encryption}\mbox{}\\
After constructing the full buffer—comprising the header, the Beacon ID, and the selected payload data—the malware calculates the total plaintext size. It then allocates a new memory region and invokes the RC4 encryption routine.

Crucially, the \textbf{entire packet structure} is encrypted using the session-specific RC4 key retrieved during the initial handshake. This ensures that all fields, including the packet headers and the victim's identity, are completely obfuscated from network inspection.

\subsubsection{Command Dispatching and Task Execution}


Upon successfully checking in with the C2 server (via a POST request), the malware receives an encrypted response. It decrypts this response buffer using the session RC4 key.


\begin{figure}[H]
    \centering
     
    \includegraphics[width=1.0\textwidth]{images/c2command.png}
    \captionsetup{list=yes}
    \caption{Decompiled switch logic handling the parsed Command IDs.}
    \label{fig:c2_command_dispatch}
\end{figure}

The decrypted packet follows a specific structure where the second 4-byte integer (at index \texttt{v20[1]}) represents the \textbf{Command ID}. The malware parses this ID to determine which malicious task to execute. Based on the analysis of the dispatch loop (Figure~\ref{fig:c2_command_dispatch}), the malware supports the following primary commands:

\begin{table}[H]
\centering
\label{tab:c2_commands}
\begin{tabularx}{\textwidth}{@{}l l X@{}}
\toprule
\textbf{Command ID (Hex)} & \textbf{Command ID (Decimal)} & \textbf{Task Description} \\ \midrule
\texttt{0x3004} & 12292 & \textbf{Payload Installation \& Execution} \newline Downloads additional malicious components (typically dropped files) to the host, installs them, and executes the payload. \\ \addlinespace
\texttt{0x3004} & 12292 & \textbf{Download and Execute Payload} \newline Initiates a routine to download three specific components (EXE, DLL, and DAT) from the C2 server. Once saved, it executes the signed binary to trigger the new payload via DLL side-loading, effectively updating the malware or loading a new module. \\ \addlinespace
\texttt{0x10000001} & 268435457 & \textbf{Update Configuration} \newline Updates the internal configuration of the malware (e.g., C2 addresses, sleep timers) with new data provided by the server. \\ \addlinespace
\texttt{0x7002} & 28674 & \textbf{Reverse Shell} \newline Initiates a remote shell session, allowing the attacker to execute arbitrary commands on the victim machine. \\
\bottomrule
\end{tabularx}

\caption{Supported C2 Command IDs and Functionality}
\end{table}

\paragraph{Command 0x3004: Download and Execute Payload}\mbox{}\\
When the Command ID \texttt{0x3004} is received, the malware initiates a routine to fetch and execute a new payload. This mechanism is typically used to update the malware agent or install additional modules.

The routine calls the internal function \texttt{mw\_download\_file\_from\_server} three consecutive times. Based on the arguments passed (flags 1, 2, and 3), it attempts to download the complete PlugX loading triad:

\begin{enumerate}
    \item \textbf{Executable (Flag 1):} A signed, legitimate executable (the Loader).
    \item \textbf{DLL (Flag 2):} The malicious library to be side-loaded.
    \item \textbf{Data File (Flag 3):} The encrypted shellcode payload.
\end{enumerate}

The routine maintains a success counter. Only if all three downloads complete successfully (counter equals 3) does the execution flow proceed.

Once the files are successfully written to disk, the malware resolves the path to the downloaded executable. It then invokes \texttt{mw\_CreateProcess\_wrapper} to launch the new process. This triggers the side-loading chain of the new payload, effectively handing over control to the updated version or new module.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/download_and_execute_payloads.png}
    \caption[]{Decompiled logic showing the download of 3 distinct files followed by process creation.}
    \label{fig:download_exec}
\end{figure}

\paragraph{Command 0x1005: Self-Destruct and Cleanup}\mbox{}\\
When the malware receives the command ID \texttt{0x1005}, it initiates a self-destruct sequence to remove all traces of the infection from the host system.
 
First, the malware targets its persistence mechanisms. It attempts to open the standard Windows "Run" keys in both the System and User registry hives and deletes the value named \texttt{"Aspex Update"}:

\begin{itemize}
    \item \texttt{HKLM\textbackslash Software\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Run\textbackslash Aspex Update}
    \item \texttt{HKCU\textbackslash Software\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Run\textbackslash Aspex Update}
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{images/cleanupreg_and_create_bat.png}
    \caption[]{ProcMon log showing the deletion of registry run keys and creation of the cleanup script.}
    \label{fig:cleanup_log}
\end{figure}

To delete its executable files while they are potentially still in use, the malware drops a temporary batch script named \texttt{del\_AspexHelperRMy.bat} into the \texttt{\%TEMP\%} directory.

The content of this script is hardcoded to perform a delayed deletion:

\begin{lstlisting}[language=Verilog, caption=Content of the Self-Destruct Batch Script]
ping 127.0.0.1 -n 5 >nul 2 >nul  :: Delay execution to allow main process to exit
C:
cd C:\ProgramData\MSDN\AspexHelperRMy\
del *.* /f /s /q /a              :: Force delete all files
cd ..
rd /q /s C:\ProgramData\MSDN\AspexHelperRMy\ :: Remove the directory
del %0                           :: Delete the batch script itself
\end{lstlisting}

Finally, the malware executes this script using \texttt{cmd.exe} and immediately terminates its own process. The \texttt{ping} command in the script acts as a sleep timer, ensuring the malware process has fully exited and released its file locks before the deletion commands attempt to remove the binaries.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/rundelbat.png}
    \caption[]{Execution of the deletion script via cmd.exe.}
    \label{fig:run_del_bat}
\end{figure}

\paragraph{Command 0x10000001: Update Configuration}\mbox{}\\
When the malware receives the Command ID \texttt{0x10000001}, it triggers a routine to modify its runtime configuration parameters. The payload associated with this command is expected to be a comma-separated string (CSV).
 
The routine parses the received string using the delimiter \texttt{","}. It iterates through the tokens and converts them from string to integer using \texttt{atoi}, updating the following global variables in order:

\begin{enumerate}
    \item \textbf{Token 1 (Index 0):} Updates \texttt{gb\_jitter}. This value represents the sleep duration or "jitter" interval the malware waits between consecutive C2 check-ins, introducing randomness to evade traffic analysis.
    \item \textbf{Token 2 (Index 1):} Updates \texttt{gb\_timeout\_settings}. This value controls the connection, receive, and send timeouts for HTTP transactions, as previously detailed in the connection configuration section (see Figure~\ref{fig:http_timeouts}).
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/updateconfig.png}
    \caption[]{Decompiled logic showing the parsing of configuration updates via strtok.}
    \label{fig:config_update}
\end{figure}


\paragraph{Command 0x7002: Reverse Shell}

When the Command ID \texttt{0x7002} is received, the malware executes \texttt{mw\_reverse\_shell}. This function establishes a fully interactive remote command shell, allowing the attacker to execute arbitrary Windows commands and receive their output in real-time.
 
To achieve interactivity without writing to disk, the malware employs a classic anonymous pipe architecture coupled with multi-threading. The setup process is as follows:

\begin{enumerate}
    \item \textbf{Pipe Creation:} The malware creates two anonymous pipes using \texttt{CreatePipe}:
    \begin{itemize}
        \item \textbf{Pipe 1 (Output Pipe):} Captures \texttt{stdout} and \texttt{stderr} from the command processor.
        \item \textbf{Pipe 2 (Input Pipe):} Feeds commands from the malware into the \texttt{stdin} of the command processor.
    \end{itemize}
    \item \textbf{Process Spawning:} It spawns an instance of \texttt{cmd.exe} with the \texttt{STARTF\_USESTDHANDLES} flag, explicitly redirecting the process's standard input/output streams to the handles of the created pipes.
    \item \textbf{Thread Management:} Two dedicated worker threads are created to bridge the gap between the C2 server and the local command processor:
    \begin{itemize}
        \item \textbf{Thread 1 (Command Fetcher):} Continuously sends POST requests to the C2 server to retrieve pending shell commands. When a command is received, it writes the data into \textbf{Pipe 2}, effectively "typing" it into the \texttt{cmd.exe} console.
        \item \textbf{Thread 2 (Result Uploader):} Continuously reads the execution results from \textbf{Pipe 1}. It packages this output and transmits it back to the C2 server via a separate POST request.
    \end{itemize}
\end{enumerate}

This architecture creates a full-duplex communication channel, as illustrated in the diagram below.


\begin{figure}[H]
    \centering
    
\captionsetup{list=yes} 
    \includegraphics[width=1\textwidth]
    {images/reverse_shell_flow.png}
    \caption{Architectural data flow of the multi-threaded reverse shell module.}
\label{fig:reverse_shell_flow_improved}
\end{figure}

\chapter{Indicators of Compromise}

The following sections outline the technical artifacts identified during the analysis of the AspexHelperRMy (PlugX Variant) sample. These indicators can be used for detection, hunting, and blocking within security environments.

\section{Malicious File Artifacts and Hashes}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.5}
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\textbf{Description} & \textbf{Details} \\ \hline
\textbf{Loader (Signed)} & \textbf{Filename:} aspex\_helper.exe \newline
\textbf{SHA256:} \seqsplit{ff2ba3ae5fb195918ffaa542055e800ffb34815645d39377561a3abdfdea2239} \\ \hline
\textbf{Encrypted Payload} & \textbf{Filename:} aspex\_log.dat \newline
\textbf{SHA256:} \seqsplit{bc8091166abc1f792b895e95bf377adc542828eac934108250391dabf3f57df9} \\ \hline
\textbf{Side-Loaded DLL} & \textbf{Filename:} RBGUIFramework.dll \newline
\textbf{SHA256:} \seqsplit{9f57f0df4e047b126b40f88fdbfdba7ced9c30ad512bfcd1c163ae28815530a6} \\ \hline
\end{tabularx}

\caption{Malicious File Artifacts and Hashes}
\end{table}

\section{Host-Based Artifacts}

\subsection{FileSystem Paths}
The malware utilizes specific directories for installation, data staging, error logging, and temporary execution.

\begin{itemize}
    \item \textbf{Primary Installation Directory:} \newline \texttt{\%ALLUSERSPROFILE\%\textbackslash MSDN\textbackslash AspexHelperRMy\textbackslash} 
    \item \textbf{Secondary Installation Directory (User):} \newline \texttt{\%USERPROFILE\%\textbackslash AspexHelperRMy\textbackslash}
    \item \textbf{Data Exfiltration Staging:} \newline \texttt{\%AppData\%\textbackslash Roaming\textbackslash Document\textbackslash} 
    \item \textbf{WiFi Credential Staging:} \newline \texttt{\%TEMP\%\textbackslash WiFi\textbackslash} 
    \item \textbf{Error Logging:} \newline \texttt{\%ALLUSERSPROFILE\%\textbackslash SxS\textbackslash bug.log}
    \item \textbf{Transient Reconnaissance Data:} \newline \texttt{\%TEMP\%\textbackslash [VictimID]\_[USB\_Drive].dat} (e.g., \texttt{...3F946C3D8DDD0EBA\_E.dat})
    \item \textbf{Temporary Batch Execution:} \newline \texttt{\%TEMP\%\textbackslash [Rand].bat} (e.g., \texttt{102AE0D.bat})
\end{itemize}

\subsection{Abused System Binaries}
The malware leverages legitimate Windows system executables to bypass security controls and mask its activity.

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabularx}{\textwidth}{|l|l|X|}
\hline
\textbf{Binary / Command} & \textbf{Path / Utility} & \textbf{Malicious Usage} \\ \hline
\textbf{fodhelper.exe} & \texttt{\%windir\%\textbackslash system32\textbackslash fodhelper.exe}  & \textbf{UAC Bypass:} Executed to auto-elevate privileges via the hijacked registry key \texttt{ms-settings\textbackslash CurVer} \\ \hline
\textbf{dllhost.exe} & \texttt{\%windir\%\textbackslash system32\textbackslash dllhost.exe} & \textbf{Process Injection:} Spawned in a suspended state to host the injected PlugX payload (\texttt{Argc} = 4). \\ \hline
\textbf{netsh wlan} & \texttt{\%windir\%\textbackslash system32\textbackslash netsh.exe} & \textbf{Credential Theft \& Connectivity:} Used to harvest plaintext Wi-Fi profiles and restore network access \\ \hline
\end{tabularx}
\caption{Legitimate System Binaries and Commands Abused}
\end{table}

\subsection{Specific Command Line Arguments}
The following blocks capture the full command-line arguments used by the malware for persistence and network manipulation.

\subsubsection{Scheduled Task Commands}

\begin{lstlisting}[breaklines=true, basicstyle=\ttfamily\scriptsize, frame=single, caption=Scheduled Task Commands (Example)]
SCHTASKS.exe /run /tn "AspexUpdateTask"

SCHTASKS.exe /create /sc minute /mo 30 /tn "AspexUpdateTask" /tr "\"\"\"C:\ProgramData\MSDN\AspexHelperRMy\aspex_helper.exe\"\"\" Rand1 Rand2 Rand3" /f

SCHTASKS.exe /create /sc minute /mo 30 /tn "AspexUpdateTask" /tr "\"\"\"C:\ProgramData\MSDN\AspexHelperRMy\aspex_helper.exe\"\"\" Rand1 Rand2 Rand3" /ru "SYSTEM" /f
\end{lstlisting}

\subsubsection{WiFi Credential and Connectivity Commands}

\begin{lstlisting}[breaklines=true, basicstyle=\ttfamily\scriptsize, frame=single, caption=Netsh WLAN Commands Executed]
rem Command to export all Wi-Fi profiles in plaintext (key=clear)
%comspec% /c netsh wlan export profile key=clear folder="%TEMP%\WiFi"

rem Command to scan for nearby SSIDs (used for connection validation)
%comspec% /c netsh wlan show networks | find "SSID"

rem Commands to forcibly restore connectivity: 
%comspec% /c netsh wlan disconnect
%comspec% /c netsh wlan add profile filename="[Path_To_Profile.xml]"
%comspec% /c netsh wlan connect name="[SSID]"
\end{lstlisting}
\section{Registry Artifacts}

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\section{Registry Artifacts}

\begin{table}[H]
\centering
\caption{Registry Keys and Values modified by the malware}
\renewcommand{\arraystretch}{1.3}
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\textbf{Category} & \textbf{Key / Value / Purpose} \\ \hline
\textbf{Victim Fingerprint} & \textbf{Key:} \seqsplit{HKEY\_LOCAL\_MACHINE\textbackslash Software\textbackslash CLASSES\textbackslash ms-pu\textbackslash CLSID} \newline
\textbf{Key:} \seqsplit{HKEY\_CURRENT\_USER\textbackslash Software\textbackslash CLASSES\textbackslash ms-pu\textbackslash CLSID} \newline
\textbf{Format:} 16-byte Hex string (e.g., \texttt{\%2.2X...}) \\ \hline
\textbf{Persistence (Run)} & \textbf{Key:} \seqsplit{HKEY\_CURRENT\_USER\textbackslash Software\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Run} \newline
\textbf{Value Name:} \texttt{Aspex Update} \\ \hline
\textbf{UAC Bypass} & \textbf{Key:} \seqsplit{HKEY\_CURRENT\_USER\textbackslash Software\textbackslash Classes\textbackslash ms-settings\textbackslash CurVer} \newline
\textbf{Value:} \texttt{.pow} \\ \hline
\textbf{UAC Command} & \textbf{Key:} \seqsplit{HKEY\_CURRENT\_USER\textbackslash Software\textbackslash Classes\textbackslash .pow\textbackslash Shell\textbackslash Open\textbackslash command} \newline
\textbf{Value:} Path to malicious executable with arguments. \\ \hline
\textbf{Explorer Tampering} & \textbf{Key:} \seqsplit{HKEY\_CURRENT\_USER\textbackslash Software\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Explorer\textbackslash Advanced} \newline
\textbf{Values:} \texttt{Hidden=0}, \texttt{ShowSuperHidden=0}, \texttt{HideFileExt=1} \\ \hline
\textbf{Network Proxy Settings} & \textbf{Key (Base):} \seqsplit{HKEY\_CURRENT\_USER\textbackslash Software\textbackslash Microsoft\textbackslash Windows\textbackslash CurrentVersion\textbackslash Internet Settings} \newline
\textbf{Value (Enable):} Reads \texttt{ProxyEnable} to check if a proxy is active ($1=\text{active}$). \newline
\textbf{Value (Server):} Reads \texttt{ProxyServer} to retrieve the proxy address and port. \\ \hline
\textbf{USB/C2 Policy Control} & \textbf{Key (Base):} \seqsplit{HKEY\_CURRENT\_USER\textbackslash System\textbackslash CurrentControlSet\textbackslash Control\textbackslash Network\textbackslash} \newline
\textbf{Value (Fingerprint):} Reads/Writes USB device IDs to prevent re-infection. \newline
\textbf{Value (Proxy Check/Skip):} Reads \texttt{proxy} to skip batch script execution if a proxy is manually set ($1=\text{skip}$). \newline
\textbf{Value (Global Kill-Switch):} Reads \texttt{allow} to disable USB propagation if set to \texttt{1}. \\ \hline
\end{tabularx}
\end{table}

\caption{Registry Keys and Values modified by the malware}
\end{table}

\section{Network Artifacts}

\subsection{C2 Communication Signatures}
\begin{itemize}
    \item \textbf{Decoy Check:} Connection to \texttt{www.microsoft.com} on port 443.
   \item \textbf{User-Agent:} Dynamically generated string mimicking Internet Explorer. Full Pattern: \newline
    \texttt{Mozilla/5.0 (compatible; MSIE \{IE\_Ver\}; Windows NT \{OS\_Major\}.\{OS\_Minor\}; \\ \{System\_Post\_Platform\}; \{Machine\_Post\_Platform\}; \{User\_Post\_Platform\_5.0\}; \\ \{User\_Post\_Platform\})}
    \item \textbf{Custom Headers (Regex Pattern):}
    \begin{itemize}
        \item \textbf{X-Oss-Request-Id:} \newline
        \texttt{X-Oss-Request-Id:\textbackslash s+[0-9A-Fa-f]\{2\}.\{6\}} \newline
        \textit{Description:} Composed of a random hex number followed by a random alphanumeric checksum string.
        \item \textbf{X-Cache:} \newline
        \texttt{X-Cache:\textbackslash s+[0-9A-Fa-f]\{36\}} \newline
        \textit{Description:} Concatenation of two random hex bytes (4 chars) and the 16-byte Victim ID (32 chars).
    \end{itemize}
    \item \textbf{Content-Type Enforcement:} The malware only accepts responses with \texttt{Content-Type: application/octet-stream}.
\end{itemize}

\subsection{Command and Control (C2) Domains}
The malware configuration contains three slots for C2 servers. All are configured to communicate over port 443 (HTTPS).

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabularx}{\textwidth}{|X|l|}
\hline
\textbf{Domain} & \textbf{Port} \\ \hline
\texttt{www[.]kentscaffolders[.]com} & 443  \\ \hline
\texttt{sports[.]ynnun[.]com} & 443  \\ \hline
\end{tabularx}

\caption{C2 Domains Extracted from Decrypted Configuration}
\end{table}

\section{USB Propagation Artifacts}

These artifacts are specific to removable drives infected by this sample.

\begin{table}[H]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\textbf{Type} & \textbf{Details} \\ \hline
\textbf{Hidden Directories} & 
\texttt{[USB]:\textbackslash Firmware\textbackslash }  \newline
\texttt{[USB]:\textbackslash Firmware\textbackslash vault\textbackslash}  \newline
\texttt{[USB]:\textbackslash Information Volume\textbackslash} 
\newline
\texttt{[USB]:\textbackslash Information Volume\textbackslash WiFi\textbackslash} 
\newline
\texttt{[USB]:\textbackslash Information Volume\textbackslash 2\textbackslash} 
\newline
\texttt{[USB]:\textbackslash Information Volume\textbackslash 2\textbackslash p\textbackslash}
\newline 
\texttt{[USB]:\textbackslash Information Volume\textbackslash 2\textbackslash p2\textbackslash} 
\newline
\texttt{[USB]:\textbackslash Information Volume\textbackslash 2\textbackslash [VictimID]\textbackslash} \\ \hline
\textbf{Decoy Folders} & Folder named with Unicode \textbf{0x200B} (Zero Width Space). \newline
Contains the user's original files. \\ \hline
\textbf{Malicious Shortcut} & LNK file in root directory using the Drive's Volume Name or default \texttt{Removable
Disk.lnk}. \newline
\textbf{Target:} \texttt{\%comspec\% /c "\^{}Firmwa\^{}re\textbackslash vault\textbackslash aspex\_helper.exe rand1 rand2"} \\ \hline
\textbf{Beacon Log} & \texttt{[USB]:\textbackslash Firmware\textbackslash vault\textbackslash link.dat} (Encrypted) \\ \hline
\textbf{CLSIDs Injected} & \textbf{Favorites Folder:} \texttt{\{323CA680-C24D-4099-B94D-446DD2D7249E\}} \newline
(Found in \texttt{\textbackslash Firmware\textbackslash desktop.ini}) \newline
\textbf{System Folder:} \texttt{\{88C6C381-2E85-11D0-94DE-444553540000\}} \newline
(Found in \texttt{\textbackslash Information Volume\textbackslash 2\textbackslash desktop.ini}) \\ \hline
\end{tabularx}

\caption{Artifacts present on infected USB drives}
\end{table}

\end{document}